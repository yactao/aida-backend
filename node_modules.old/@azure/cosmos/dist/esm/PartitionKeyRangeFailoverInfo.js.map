{"version":3,"file":"PartitionKeyRangeFailoverInfo.js","sourceRoot":"","sources":["../../src/PartitionKeyRangeFailoverInfo.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants, DiagnosticNodeInternal } from \"./index.js\";\nimport semaphore from \"semaphore\";\n\n/**\n * @hidden\n * This class manages the failover information for partition key ranges in Cosmos DB.\n * It tracks the current endpoint, failed endpoints, and the number of consecutive read/write request failures.\n */\nexport class PartitionKeyRangeFailoverInfo {\n  private failedEndPoints: string[] = [];\n  private currentEndPoint: string;\n\n  private consecutiveReadRequestFailureCount: number = 0;\n  private consecutiveWriteRequestFailureCount: number = 0;\n  private firstRequestFailureTime: number = Date.now();\n  private lastRequestFailureTime: number = Date.now();\n\n  private failureCountSemaphore: semaphore.Semaphore;\n  private tryMoveNextLocationSemaphore: semaphore.Semaphore;\n\n  /**\n   * @internal\n   */\n  constructor(currentEndpoint: string) {\n    this.currentEndPoint = currentEndpoint;\n    this.failureCountSemaphore = semaphore(1);\n    this.tryMoveNextLocationSemaphore = semaphore(1);\n  }\n\n  /**\n   * Checks if the circuit breaker can trigger a partition failover based on the failure counts.\n   * Returns true if the number of consecutive failures exceeds the defined thresholds for read or write requests.\n   */\n  public async canCircuitBreakerTriggerPartitionFailOver(\n    isReadOnlyRequest: boolean,\n  ): Promise<boolean> {\n    const { consecutiveReadRequestFailureCount, consecutiveWriteRequestFailureCount } =\n      await this.snapshotConsecutiveRequestFailureCount();\n\n    return isReadOnlyRequest\n      ? consecutiveReadRequestFailureCount > Constants.ReadRequestFailureCountThreshold\n      : consecutiveWriteRequestFailureCount > Constants.WriteRequestFailureCountThreshold;\n  }\n\n  /**\n   * Increments the failure counts for read or write requests and updates the timestamps.\n   * If the time since the last failure exceeds the reset window, it resets the failure counts.\n   */\n  public async incrementRequestFailureCounts(\n    isReadOnlyRequest: boolean,\n    currentTimeInMilliseconds: number,\n  ): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.failureCountSemaphore.take(async () => {\n        try {\n          const { lastRequestFailureTime } = await this.snapshotPartitionFailoverTimestamps();\n\n          if (\n            currentTimeInMilliseconds - lastRequestFailureTime >\n            Constants.ConsecutiveFailureCountResetIntervalInMS\n          ) {\n            this.consecutiveReadRequestFailureCount = 0;\n            this.consecutiveWriteRequestFailureCount = 0;\n          }\n\n          if (isReadOnlyRequest) {\n            this.consecutiveReadRequestFailureCount++;\n          } else {\n            this.consecutiveWriteRequestFailureCount++;\n          }\n          this.lastRequestFailureTime = currentTimeInMilliseconds;\n          return resolve();\n        } catch (error) {\n          reject(error);\n        } finally {\n          // Release the semaphore lock\n          this.failureCountSemaphore.leave();\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns a snapshot of the first and last request failure timestamps.\n   * This method is used to retrieve the current state of failure timestamps without modifying them.\n   */\n  public async snapshotPartitionFailoverTimestamps(): Promise<{\n    firstRequestFailureTime: number;\n    lastRequestFailureTime: number;\n  }> {\n    return {\n      firstRequestFailureTime: this.firstRequestFailureTime,\n      lastRequestFailureTime: this.lastRequestFailureTime,\n    };\n  }\n\n  /**\n   * Attempts to move to the next available location for the partition key range.\n   * If the current endpoint is the same as the failed endpoint, it tries to find a new endpoint\n   * from the provided list of endpoints. If a new endpoint is found, it updates the current endpoint\n   * and returns true. If no new endpoint is found, it returns false.\n   */\n  public async tryMoveNextLocation(\n    endPoints: readonly string[],\n    failedEndPoint: string,\n    diagnosticNode: DiagnosticNodeInternal,\n    partitionKeyRangeId: string,\n  ): Promise<boolean> {\n    if (failedEndPoint !== this.currentEndPoint) {\n      return true;\n    }\n    return new Promise((resolve, reject) => {\n      this.tryMoveNextLocationSemaphore.take(() => {\n        try {\n          for (const endpoint of endPoints) {\n            if (this.currentEndPoint === endpoint) {\n              continue;\n            }\n\n            if (this.failedEndPoints.includes(endpoint)) {\n              continue;\n            }\n\n            this.failedEndPoints.push(failedEndPoint);\n            this.currentEndPoint = endpoint;\n            return resolve(true);\n          }\n          diagnosticNode.addData({\n            partitionKeyRangeFailoverInfo: `PartitionKeyRangeId: ${partitionKeyRangeId}, failedLocations: ${this.failedEndPoints}, newLocation: ${this.currentEndPoint}`,\n          });\n          return resolve(false);\n        } catch (err) {\n          reject(err);\n        } finally {\n          this.tryMoveNextLocationSemaphore.leave();\n        }\n      });\n    });\n  }\n\n  /** Returns the current endpoint being used for partition key range operations.*/\n  public getCurrentEndPoint(): string {\n    return this.currentEndPoint;\n  }\n\n  /**\n   * Returns a snapshot of the current consecutive request failure counts for read and write requests.\n   * This method is used to retrieve the current state of failure counts without modifying them.\n   */\n  private async snapshotConsecutiveRequestFailureCount(): Promise<{\n    consecutiveReadRequestFailureCount: number;\n    consecutiveWriteRequestFailureCount: number;\n  }> {\n    return {\n      consecutiveReadRequestFailureCount: this.consecutiveReadRequestFailureCount,\n      consecutiveWriteRequestFailureCount: this.consecutiveWriteRequestFailureCount,\n    };\n  }\n}\n"]}