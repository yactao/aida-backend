{"version":3,"file":"endpointDiscoveryRetryPolicy.js","sourceRoot":"","sources":["../../../src/retry/endpointDiscoveryRetryPolicy.ts"],"names":[],"mappings":";;;AAGA,iDAAiE;AACjE,mDAAoD;AAOpD;;;GAGG;AACH,MAAa,4BAA4B;IAe7B;IACA;IACA;IACA;IAjBV,mCAAmC;IAC5B,wBAAwB,CAAS;IACxC,sCAAsC;IAC/B,cAAc,CAAS;IAE9B,+CAA+C;IACvC,QAAQ,CAAS;IACjB,MAAM,CAAU,QAAQ,GAAG,GAAG,CAAC,CAAC,kBAAkB;IAClD,MAAM,CAAU,cAAc,GAAG,IAAI,CAAC;IAE9C;;OAEG;IACH,YACU,qBAA4C,EAC5C,YAA0B,EAC1B,aAA4B,EAC5B,8BAA+D;QAH/D,0BAAqB,GAArB,qBAAqB,CAAuB;QAC5C,iBAAY,GAAZ,YAAY,CAAc;QAC1B,kBAAa,GAAb,aAAa,CAAe;QAC5B,mCAA8B,GAA9B,8BAA8B,CAAiC;QAEvE,IAAI,CAAC,QAAQ,GAAG,4BAA4B,CAAC,QAAQ,CAAC;QACtD,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,cAAc,GAAG,4BAA4B,CAAC,cAAc,CAAC;IACpE,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,WAAW,CACtB,GAAkB,EAClB,cAAsC,EACtC,YAA2B,EAC3B,gBAAyB,EACzB,cAA+B;QAE/B,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,YAAY,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvC,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,uBAAuB,EAAE,CAAC;YACxD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,IAAI,CAAC,8BAA8B,EAAE,CAAC;YACxC,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,8BAA8B,CAAC,yBAAyB,CACrF,cAAc,EACd,cAAc,CACf,CAAC;YACF,IAAI,WAAW,EAAE,CAAC;gBAChB,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;QAED,IAAI,IAAI,CAAC,wBAAwB,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,YAAY,CAAC,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC;QACxD,YAAY,CAAC,6BAA6B,GAAG,KAAK,CAAC;QACnD,YAAY,CAAC,gCAAgC,GAAG,KAAK,CAAC;QACtD,cAAc,CAAC,OAAO,CAAC,EAAE,qBAAqB,EAAE,mBAAmB,EAAE,CAAC,CAAC;QAEvE,8CAA8C;QAC9C,2FAA2F;QAC3F,IAAI,IAAI,CAAC,YAAY,KAAK,uBAAY,CAAC,IAAI,IAAI,IAAI,CAAC,aAAa,KAAK,wBAAa,CAAC,IAAI,EAAE,CAAC;YACzF,OAAO,IAAI,CAAC;QACd,CAAC;QAED,IAAI,IAAA,yBAAa,EAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC;YACtC,MAAM,IAAI,CAAC,qBAAqB,CAAC,qCAAqC,CACpE,cAAc,EACd,gBAAgB,CACjB,CAAC;QACJ,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,CAAC,qBAAqB,CAAC,sCAAsC,CACrE,cAAc,EACd,gBAAgB,CACjB,CAAC;QACJ,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;;AAtFH,oEAuFC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { OperationType, ResourceType } from \"../common/index.js\";\nimport { isReadRequest } from \"../common/helper.js\";\nimport type { GlobalEndpointManager } from \"../globalEndpointManager.js\";\nimport type { ErrorResponse, RequestContext } from \"../request/index.js\";\nimport type { RetryContext } from \"./RetryContext.js\";\nimport type { RetryPolicy } from \"./RetryPolicy.js\";\nimport { GlobalPartitionEndpointManager } from \"../globalPartitionEndpointManager.js\";\n\n/**\n * This class implements the retry policy for endpoint discovery.\n * @hidden\n */\nexport class EndpointDiscoveryRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount: number;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs: number;\n\n  /** Max number of retry attempts to perform. */\n  private maxTries: number;\n  private static readonly maxTries = 120; // TODO: Constant?\n  private static readonly retryAfterInMs = 1000;\n\n  /**\n   * @param globalEndpointManager - The GlobalEndpointManager instance.\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private globalPartitionEndpointManager?: GlobalPartitionEndpointManager,\n  ) {\n    this.maxTries = EndpointDiscoveryRetryPolicy.maxTries;\n    this.currentRetryAttemptCount = 0;\n    this.retryAfterInMs = EndpointDiscoveryRetryPolicy.retryAfterInMs;\n  }\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n    retryContext?: RetryContext,\n    locationEndpoint?: string,\n    requestContext?: RequestContext,\n  ): Promise<boolean | [boolean, string]> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext || !locationEndpoint) {\n      return false;\n    }\n\n    if (!this.globalEndpointManager.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (this.globalPartitionEndpointManager) {\n      const didFailover = await this.globalPartitionEndpointManager.tryPartitionLevelFailover(\n        requestContext,\n        diagnosticNode,\n      );\n      if (didFailover) {\n        return true;\n      }\n    }\n\n    if (this.currentRetryAttemptCount >= this.maxTries) {\n      return false;\n    }\n\n    this.currentRetryAttemptCount++;\n    retryContext.retryCount = this.currentRetryAttemptCount;\n    retryContext.clearSessionTokenNotAvailable = false;\n    retryContext.retryRequestOnPreferredLocations = false;\n    diagnosticNode.addData({ successfulRetryPolicy: \"endpointDiscovery\" });\n\n    // check if this is a readDatabaseAccount call\n    // If yes, then simply return true (avoid recursive call triggered for readDatabaseAccount)\n    if (this.resourceType === ResourceType.none && this.operationType === OperationType.Read) {\n      return true;\n    }\n\n    if (isReadRequest(this.operationType)) {\n      await this.globalEndpointManager.markCurrentLocationUnavailableForRead(\n        diagnosticNode,\n        locationEndpoint,\n      );\n    } else {\n      await this.globalEndpointManager.markCurrentLocationUnavailableForWrite(\n        diagnosticNode,\n        locationEndpoint,\n      );\n    }\n    return true;\n  }\n}\n"]}