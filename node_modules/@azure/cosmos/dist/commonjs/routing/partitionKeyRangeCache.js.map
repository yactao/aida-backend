{"version":3,"file":"partitionKeyRangeCache.js","sourceRoot":"","sources":["../../../src/routing/partitionKeyRangeCache.ts"],"names":[],"mappings":";;;AAAA,uCAAuC;AACvC,kCAAkC;AAClC,kEAA6D;AAG7D,mDAAoD;AAEpD,4DAAkE;AAClE,qFAA4E;AAK5E,sDAA8F;AAE9F,cAAc;AACd,MAAa,sBAAsB;IAKb;IAJZ,kCAAkC,CAExC;IAEF,YAAoB,aAA4B;QAA5B,kBAAa,GAAb,aAAa,CAAe;QAC9C,IAAI,CAAC,kCAAkC,GAAG,EAAE,CAAC;IAC/C,CAAC;IACD;;;;OAIG;IACI,KAAK,CAAC,sBAAsB,CACjC,cAAsB,EACtB,cAAsC,EACtC,eAAwB,KAAK;QAE7B,MAAM,YAAY,GAAG,IAAA,yBAAa,EAAC,cAAc,CAAC,CAAC;QACnD,IAAI,IAAI,CAAC,kCAAkC,CAAC,YAAY,CAAC,KAAK,SAAS,IAAI,YAAY,EAAE,CAAC;YACxF,IAAI,CAAC,kCAAkC,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,2BAA2B,CACtF,cAAc,EACd,cAAc,CACf,CAAC;QACJ,CAAC;QACD,OAAO,IAAI,CAAC,kCAAkC,CAAC,YAAY,CAAC,CAAC;IAC/D,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,oBAAoB,CAC/B,cAAsB,EACtB,UAAsB,EACtB,cAAsC,EACtC,eAAwB,KAAK;QAE7B,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;QAC5F,OAAO,GAAG,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;IAC9C,CAAC;IAEO,KAAK,CAAC,2BAA2B,CACvC,cAAsB,EACtB,cAAsC;QAEtC,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,wCAAuB,EACjD,KAAK,EAAE,mBAA2C,EAAE,EAAE;YACpD,OAAO,IAAI,CAAC,aAAa;iBACtB,uBAAuB,CAAC,cAAc,CAAC;iBACvC,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;QAC3C,CAAC,EACD,cAAc,EACd,yCAAkB,CAAC,uBAAuB,CAC3C,CAAC;QACF,OAAO,IAAA,yDAAwB,EAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,sCAAsC,CACjD,cAAsB,EACtB,YAAkC,EAClC,sBAA8C,EAC9C,cAAsC;QAEtC,MAAM,kBAAkB,GAAG,IAAA,0BAAgB,EAAC,YAAY,EAAE,sBAAsB,CAAC,CAAC;QAClF,MAAM,kBAAkB,GAAG,CACzB,MAAM,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,cAAc,CAAC,CAClE,CAAC,2BAA2B,EAAE,CAAC;QAEhC,MAAM,mBAAmB,GAAG,IAAA,0CAAgC,EAC1D,kBAAkB,EAClB,kBAAkB,CACnB,CAAC;QACF,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AA/ED,wDA+EC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { MetadataLookUpType } from \"../CosmosDiagnostics.js\";\nimport type { PartitionKeyRange } from \"../client/Container/PartitionKeyRange.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport { getIdFromLink } from \"../common/helper.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { withMetadataDiagnostics } from \"../utils/diagnostics.js\";\nimport { createCompleteRoutingMap } from \"./CollectionRoutingMapFactory.js\";\nimport type { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap.js\";\nimport type { QueryRange } from \"./QueryRange.js\";\nimport type { PartitionKeyDefinition } from \"../documents/PartitionKeyDefinition.js\";\nimport type { PartitionKeyInternal } from \"../documents/PartitionKeyInternal.js\";\nimport { hashPartitionKey, binarySearchOnPartitionKeyRanges } from \"../utils/hashing/hash.js\";\n\n/** @hidden */\nexport class PartitionKeyRangeCache {\n  private collectionRoutingMapByCollectionId: {\n    [key: string]: Promise<InMemoryCollectionRoutingMap>;\n  };\n\n  constructor(private clientContext: ClientContext) {\n    this.collectionRoutingMapByCollectionId = {};\n  }\n  /**\n   * Finds or Instantiates the requested Collection Routing Map\n   * @param collectionLink - Requested collectionLink\n   * @hidden\n   */\n  public async onCollectionRoutingMap(\n    collectionLink: string,\n    diagnosticNode: DiagnosticNodeInternal,\n    forceRefresh: boolean = false,\n  ): Promise<InMemoryCollectionRoutingMap> {\n    const collectionId = getIdFromLink(collectionLink);\n    if (this.collectionRoutingMapByCollectionId[collectionId] === undefined || forceRefresh) {\n      this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(\n        collectionLink,\n        diagnosticNode,\n      );\n    }\n    return this.collectionRoutingMapByCollectionId[collectionId];\n  }\n\n  /**\n   * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @hidden\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    queryRange: QueryRange,\n    diagnosticNode: DiagnosticNodeInternal,\n    forceRefresh: boolean = false,\n  ): Promise<PartitionKeyRange[]> {\n    const crm = await this.onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh);\n    return crm.getOverlappingRanges(queryRange);\n  }\n\n  private async requestCollectionRoutingMap(\n    collectionLink: string,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<InMemoryCollectionRoutingMap> {\n    const { resources } = await withMetadataDiagnostics(\n      async (metadataDiagnostics: DiagnosticNodeInternal) => {\n        return this.clientContext\n          .queryPartitionKeyRanges(collectionLink)\n          .fetchAllInternal(metadataDiagnostics);\n      },\n      diagnosticNode,\n      MetadataLookUpType.PartitionKeyRangeLookUp,\n    );\n    return createCompleteRoutingMap(resources.map((r) => [r, true]));\n  }\n\n  /**\n   * Given a partition key, returns the partition key range id\n   * @internal\n   */\n  public async getPartitionKeyRangeIdFromPartitionKey(\n    collectionLink: string,\n    partitionKey: PartitionKeyInternal,\n    partitionKeyDefinition: PartitionKeyDefinition,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<string | undefined> {\n    const hashedPartitionKey = hashPartitionKey(partitionKey, partitionKeyDefinition);\n    const partitionKeyRanges = (\n      await this.onCollectionRoutingMap(collectionLink, diagnosticNode)\n    ).getOrderedParitionKeyRanges();\n\n    const partitionKeyRangeId = binarySearchOnPartitionKeyRanges(\n      partitionKeyRanges,\n      hashedPartitionKey,\n    );\n    return partitionKeyRangeId;\n  }\n}\n"]}