"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceThrottleRetryPolicy = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const constants_js_1 = require("../common/constants.js");
/**
 * This class implements the resource throttle retry policy for requests.
 * @hidden
 */
class ResourceThrottleRetryPolicy {
    /** Current retry attempt count. */
    currentRetryAttemptCount = 0;
    /** Cummulative wait time in milliseconds for a request while the retries are happening. */
    cummulativeWaitTimeinMs = 0;
    /** Retry interval in milliseconds to wait before the next request will be sent. */
    retryAfterInMs = 0;
    /** Max wait time in milliseconds to wait for a request while the retries are happening. */
    timeoutInMs;
    /**
     * @param maxTries - Max number of retries to be performed for a request.
     * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each
     * retry ignoring the retryAfter returned as part of the response.
     * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the
     * retries are happening.
     */
    maxTries;
    fixedRetryIntervalInMs;
    constructor(options) {
        this.maxTries = options.maxRetryAttemptCount ?? constants_js_1.Constants.ThrottledRequestMaxRetryAttemptCount;
        this.fixedRetryIntervalInMs =
            options.fixedRetryIntervalInMilliseconds ?? constants_js_1.Constants.ThrottledRequestFixedRetryIntervalInMs;
        const timeoutInSeconds = options.maxWaitTimeInSeconds ?? constants_js_1.Constants.ThrottledRequestMaxWaitTimeInSeconds;
        this.timeoutInMs = timeoutInSeconds * 1000;
        this.currentRetryAttemptCount = 0;
        this.cummulativeWaitTimeinMs = 0;
    }
    /**
     * Determines whether the request should be retried or not.
     * @param err - Error returned by the request.
     */
    async shouldRetry(err, diagnosticNode) {
        // TODO: any custom error object
        if (err) {
            if (this.currentRetryAttemptCount < this.maxTries) {
                this.currentRetryAttemptCount++;
                this.retryAfterInMs = 0;
                if (this.fixedRetryIntervalInMs) {
                    this.retryAfterInMs = this.fixedRetryIntervalInMs;
                }
                else if (err.retryAfterInMs) {
                    this.retryAfterInMs = err.retryAfterInMs;
                }
                if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {
                    this.cummulativeWaitTimeinMs += this.retryAfterInMs;
                    diagnosticNode.addData({ successfulRetryPolicy: "resourceThrottle" });
                    return true;
                }
            }
        }
        return false;
    }
}
exports.ResourceThrottleRetryPolicy = ResourceThrottleRetryPolicy;
//# sourceMappingURL=resourceThrottleRetryPolicy.js.map