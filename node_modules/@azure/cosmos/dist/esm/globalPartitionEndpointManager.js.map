{"version":3,"file":"globalPartitionEndpointManager.js","sourceRoot":"","sources":["../../src/globalPartitionEndpointManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { OperationType, ResourceType, isReadRequest } from \"./common/index.js\";\nimport {\n  Constants,\n  DiagnosticNodeInternal,\n  type CosmosClientOptions,\n  type GlobalEndpointManager,\n  type RequestContext,\n} from \"./index.js\";\nimport { PartitionKeyRangeFailoverInfo } from \"./PartitionKeyRangeFailoverInfo.js\";\nimport { normalizeEndpoint } from \"./utils/checkURL.js\";\nimport { startBackgroundTask } from \"./utils/time.js\";\nimport { assertNotUndefined } from \"./utils/typeChecks.js\";\n\n/**\n * @hidden\n * This class is used to failover single partitions to different regions.\n */\nexport class GlobalPartitionEndpointManager {\n  private readonly partitionKeyRangeToLocationForWrite: Map<string, PartitionKeyRangeFailoverInfo>;\n  private readonly partitionKeyRangeToLocationForReadAndWrite: Map<\n    string,\n    PartitionKeyRangeFailoverInfo\n  >;\n  private enablePartitionLevelFailover: boolean;\n  private enablePartitionLevelCircuitBreaker: boolean;\n  private preferredLocations: string[];\n  public preferredLocationsCount: number;\n  private circuitBreakerFailbackBackgroundRefresher: NodeJS.Timeout;\n\n  /**\n   * @internal\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private globalEndpointManager: GlobalEndpointManager,\n  ) {\n    this.partitionKeyRangeToLocationForWrite = new Map<string, PartitionKeyRangeFailoverInfo>();\n    this.partitionKeyRangeToLocationForReadAndWrite = new Map<\n      string,\n      PartitionKeyRangeFailoverInfo\n    >();\n\n    this.enablePartitionLevelFailover = options.connectionPolicy.enablePartitionLevelFailover;\n    this.enablePartitionLevelCircuitBreaker =\n      options.connectionPolicy.enablePartitionLevelCircuitBreaker ||\n      options.connectionPolicy.enablePartitionLevelFailover;\n\n    this.preferredLocations = options.connectionPolicy.preferredLocations;\n    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;\n    if (this.enablePartitionLevelCircuitBreaker) {\n      this.initiateCircuitBreakerFailbackLoop();\n    }\n  }\n\n  /**\n   * Checks eligibility of the request for partition failover and\n   * tries to mark the endpoint unavailable for the partition key range. Future\n   * requests will be routed to the next location if available.\n   */\n  public async tryPartitionLevelFailover(\n    requestContext: RequestContext,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    if (!(await this.isRequestEligibleForPartitionFailover(requestContext, true))) {\n      return false;\n    }\n\n    const isRequestEligibleForPerPartitionAutomaticFailover =\n      this.isRequestEligibleForPerPartitionAutomaticFailover(requestContext);\n    const isRequestEligibleForPartitionLevelCircuitBreaker =\n      this.isRequestEligibleForPartitionLevelCircuitBreaker(requestContext);\n\n    if (\n      isRequestEligibleForPerPartitionAutomaticFailover ||\n      (isRequestEligibleForPartitionLevelCircuitBreaker &&\n        (await this.incrementFailureCounterAndCheckFailover(\n          requestContext,\n          isRequestEligibleForPerPartitionAutomaticFailover,\n          isRequestEligibleForPartitionLevelCircuitBreaker,\n        )))\n    ) {\n      return this.tryMarkEndpointUnavailableForPartitionKeyRange(\n        requestContext,\n        diagnosticNode,\n        isRequestEligibleForPerPartitionAutomaticFailover,\n        isRequestEligibleForPartitionLevelCircuitBreaker,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Updates the DocumentServiceRequest routing location to point\n   * new a location based if a partition level failover occurred.\n   */\n  public async tryAddPartitionLevelLocationOverride(\n    requestContext: RequestContext,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<RequestContext> {\n    if (!(await this.isRequestEligibleForPartitionFailover(requestContext, false))) {\n      return requestContext;\n    }\n\n    const partitionKeyRangeId = requestContext.partitionKeyRangeId;\n\n    if (this.isRequestEligibleForPerPartitionAutomaticFailover(requestContext)) {\n      if (this.partitionKeyRangeToLocationForWrite.has(partitionKeyRangeId)) {\n        const partitionFailOver = this.partitionKeyRangeToLocationForWrite.get(partitionKeyRangeId);\n        requestContext.endpoint = partitionFailOver.getCurrentEndPoint();\n        diagnosticNode.recordEndpointResolution(requestContext.endpoint);\n        return requestContext;\n      }\n    } else if (this.isRequestEligibleForPartitionLevelCircuitBreaker(requestContext)) {\n      if (this.partitionKeyRangeToLocationForReadAndWrite.has(partitionKeyRangeId)) {\n        const partitionFailOver =\n          this.partitionKeyRangeToLocationForReadAndWrite.get(partitionKeyRangeId);\n\n        const canCircuitBreakerTriggerPartitionFailOver =\n          await partitionFailOver.canCircuitBreakerTriggerPartitionFailOver(\n            isReadRequest(requestContext.operationType),\n          );\n        if (canCircuitBreakerTriggerPartitionFailOver) {\n          requestContext.endpoint = partitionFailOver.getCurrentEndPoint();\n          diagnosticNode.recordEndpointResolution(requestContext.endpoint);\n          return requestContext;\n        }\n      }\n    }\n    return requestContext;\n  }\n\n  /**\n   * This method clears the background refresher for circuit breaker failback\n   * and stops the periodic checks for unhealthy endpoints.\n   */\n  public dispose(): void {\n    if (this.circuitBreakerFailbackBackgroundRefresher) {\n      clearTimeout(this.circuitBreakerFailbackBackgroundRefresher);\n    }\n  }\n\n  private async tryMarkEndpointUnavailableForPartitionKeyRange(\n    requestContext: RequestContext,\n    diagnosticNode: DiagnosticNodeInternal,\n    isRequestEligibleForPerPartitionAutomaticFailover: boolean,\n    isRequestEligibleForPartitionLevelCircuitBreaker: boolean,\n  ): Promise<boolean> {\n    const partitionKeyRangeId = requestContext.partitionKeyRangeId;\n    const failedEndPoint = requestContext.endpoint;\n\n    const readLocations = await this.globalEndpointManager.getReadLocations();\n    const readEndPoints: string[] = [];\n\n    if (isRequestEligibleForPerPartitionAutomaticFailover) {\n      // For any single master write accounts, the next locations to fail over will be the read regions configured at the account level.\n      for (const location of readLocations) {\n        readEndPoints.push(location.databaseAccountEndpoint);\n      }\n      return this.tryAddOrUpdatePartitionFailoverInfoAndMoveToNextLocation(\n        partitionKeyRangeId,\n        failedEndPoint,\n        readEndPoints,\n        this.partitionKeyRangeToLocationForWrite,\n        diagnosticNode,\n      );\n    } else if (isRequestEligibleForPartitionLevelCircuitBreaker) {\n      // For the read requests or multi-master write requests, the next locations to fail over will be the preferred locations\n      // configured at the account level plus any other read locations that are not already in the preferred locations.\n      if (this.preferredLocations && this.preferredLocations.length > 0) {\n        for (const preferredLocation of this.preferredLocations) {\n          const location = readLocations.find(\n            (loc) => normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation),\n          );\n          if (location) {\n            readEndPoints.push(location.databaseAccountEndpoint);\n          }\n        }\n\n        // Add the rest of the locations not already added\n        for (const location of readLocations) {\n          if (!readEndPoints.includes(location.databaseAccountEndpoint)) {\n            readEndPoints.push(location.databaseAccountEndpoint);\n          }\n        }\n      } else {\n        for (const location of readLocations) {\n          readEndPoints.push(location.databaseAccountEndpoint);\n        }\n      }\n      return this.tryAddOrUpdatePartitionFailoverInfoAndMoveToNextLocation(\n        partitionKeyRangeId,\n        failedEndPoint,\n        readEndPoints,\n        this.partitionKeyRangeToLocationForReadAndWrite,\n        diagnosticNode,\n      );\n    }\n    return false;\n  }\n\n  /**\n   * Increments the failure counter for the specified partition and checks if the partition can fail over.\n   * This method is used to determine if a partition should be failed over based on the number of request failures.\n   */\n  private async incrementFailureCounterAndCheckFailover(\n    requestContext: RequestContext,\n    isRequestEligibleForPerPartitionAutomaticFailover: boolean,\n    isRequestEligibleForPartitionLevelCircuitBreaker: boolean,\n  ): Promise<boolean> {\n    const partitionKeyRangeId = requestContext.partitionKeyRangeId;\n    const failedEndPoint = requestContext.endpoint;\n    let partitionKeyRangeFailoverInfo: PartitionKeyRangeFailoverInfo;\n\n    if (isRequestEligibleForPerPartitionAutomaticFailover) {\n      if (!this.partitionKeyRangeToLocationForWrite.has(partitionKeyRangeId)) {\n        // If the partition key range is not already in the map, add it\n        const failoverInfo = new PartitionKeyRangeFailoverInfo(failedEndPoint);\n        this.partitionKeyRangeToLocationForWrite.set(partitionKeyRangeId, failoverInfo);\n      }\n      partitionKeyRangeFailoverInfo =\n        this.partitionKeyRangeToLocationForWrite.get(partitionKeyRangeId);\n    } else if (isRequestEligibleForPartitionLevelCircuitBreaker) {\n      if (!this.partitionKeyRangeToLocationForReadAndWrite.has(partitionKeyRangeId)) {\n        // If the partition key range is not already in the map, add it\n        const failoverInfo = new PartitionKeyRangeFailoverInfo(failedEndPoint);\n        this.partitionKeyRangeToLocationForReadAndWrite.set(partitionKeyRangeId, failoverInfo);\n      }\n      partitionKeyRangeFailoverInfo =\n        this.partitionKeyRangeToLocationForReadAndWrite.get(partitionKeyRangeId);\n    } else {\n      return false;\n    }\n\n    assertNotUndefined(\n      partitionKeyRangeFailoverInfo,\n      \"partitionKeyRangeFailoverInfo should be set if failover flags are true.\",\n    );\n\n    const currentTimeInMilliseconds = Date.now();\n    await partitionKeyRangeFailoverInfo.incrementRequestFailureCounts(\n      isReadRequest(requestContext.operationType),\n      currentTimeInMilliseconds,\n    );\n\n    return partitionKeyRangeFailoverInfo.canCircuitBreakerTriggerPartitionFailOver(\n      isReadRequest(requestContext.operationType),\n    );\n  }\n\n  /** Validates if the given request is eligible for partition failover. */\n  private async isRequestEligibleForPartitionFailover(\n    requestContext: RequestContext,\n    shouldValidateFailedLocation: boolean,\n  ): Promise<boolean> {\n    if (\n      !requestContext ||\n      !requestContext.operationType ||\n      !requestContext.resourceType ||\n      !requestContext.partitionKeyRangeId\n    ) {\n      return false;\n    }\n\n    const canUsePartitionLevelFailoverLocations = await this.canUsePartitionLevelFailoverLocations(\n      requestContext.operationType,\n      requestContext.resourceType,\n    );\n    if (!canUsePartitionLevelFailoverLocations) {\n      return false;\n    }\n\n    if (shouldValidateFailedLocation && !requestContext.endpoint) {\n      return false;\n    }\n    return true;\n  }\n\n  /** Determines if partition level failover locations can be used for the given request. */\n  private async canUsePartitionLevelFailoverLocations(\n    operationType?: OperationType,\n    resourceType?: ResourceType,\n  ): Promise<boolean> {\n    const readEndPoints = await this.globalEndpointManager.getReadEndpoints();\n    if (readEndPoints.length <= 1) {\n      return false;\n    }\n    if (\n      resourceType === ResourceType.item ||\n      (resourceType === ResourceType.sproc && operationType === OperationType.Execute)\n    ) {\n      // Right now, for single-master only reads are supported for circuit breaker, and writes are supported for automatic.\n      // failover. For multi master, both reads and writes are supported. Hence return true for both the cases.\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Determines if a request is eligible for per-partition automatic failover.\n   * A request is eligible if it is a write request, partition level failover is enabled,\n   * and the global endpoint manager cannot use multiple write locations for the request.\n   */\n  private isRequestEligibleForPerPartitionAutomaticFailover(\n    requestContext: RequestContext,\n  ): boolean {\n    return (\n      this.enablePartitionLevelFailover &&\n      !isReadRequest(requestContext.operationType) &&\n      !this.globalEndpointManager.canUseMultipleWriteLocations(\n        requestContext.resourceType,\n        requestContext.operationType,\n      )\n    );\n  }\n\n  /**\n   * Determines if a request is eligible for partition-level circuit breaker.\n   * This method checks if partition-level circuit breaker is enabled, and if the request is a read-only request or\n   * the global endpoint manager can use multiple write locations for the request.\n   */\n  private isRequestEligibleForPartitionLevelCircuitBreaker(\n    requestContext: RequestContext,\n  ): boolean {\n    if (!this.enablePartitionLevelCircuitBreaker) {\n      return false;\n    }\n    if (isReadRequest(requestContext.operationType)) {\n      return true;\n    }\n    return this.globalEndpointManager.canUseMultipleWriteLocations(\n      requestContext.resourceType,\n      requestContext.operationType,\n    );\n  }\n\n  /**\n   * Attempts to add or update the partition failover information and move to the next available location.\n   * This method checks if the current location for the partition key range has failed and updates the failover\n   * information to route the request to the next available location. If all locations have been tried, it removes\n   * the failover information for the partition key range. Return True if the failover information was successfully\n   * updated and the request was routed to a new location, otherwise false.\n   */\n  private async tryAddOrUpdatePartitionFailoverInfoAndMoveToNextLocation(\n    partitionKeyRangeId: string,\n    failedEndPoint: string,\n    nextEndPoints: readonly string[],\n    partitionKeyRangeToLocation: Map<string, PartitionKeyRangeFailoverInfo>,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    if (!partitionKeyRangeToLocation.has(partitionKeyRangeId)) {\n      // If the partition key range is not already in the map, add it\n      const failoverInfo = new PartitionKeyRangeFailoverInfo(failedEndPoint);\n      partitionKeyRangeToLocation.set(partitionKeyRangeId, failoverInfo);\n    }\n    const partitionFailOver = partitionKeyRangeToLocation.get(partitionKeyRangeId);\n\n    // Will return true if it was able to update to a new region\n    if (\n      await partitionFailOver.tryMoveNextLocation(\n        nextEndPoints,\n        failedEndPoint,\n        diagnosticNode,\n        partitionKeyRangeId,\n      )\n    ) {\n      return true;\n    }\n    // All the locations have been tried. Remove the override information\n    partitionKeyRangeToLocation.delete(partitionKeyRangeId);\n    return false;\n  }\n\n  /**\n   * Initiates a background loop that periodically checks for unhealthy endpoints\n   * and attempts to open connections to them. If a connection is successfully\n   * established, it initiates a failback to the original location for the partition key range.\n   * This is useful for scenarios where a partition key range has been marked as unavailable\n   * due to a circuit breaker, and we want to periodically check if the original location\n   * has become healthy again.\n   * The loop runs at a defined interval specified by Constants.StalePartitionUnavailabilityRefreshIntervalInMs.\n   */\n  private initiateCircuitBreakerFailbackLoop(): void {\n    this.circuitBreakerFailbackBackgroundRefresher = startBackgroundTask(async () => {\n      try {\n        await this.openConnectionToUnhealthyEndpointsWithFailback();\n      } catch (err) {\n        console.error(\"Failed to open connection to unhealthy endpoints: \", err);\n      }\n    }, Constants.StalePartitionUnavailabilityRefreshIntervalInMs);\n  }\n\n  /**\n   * Attempts to open connections to unhealthy endpoints and initiates failback if the connections are successful.\n   * This method checks the partition key ranges that have failed locations and tries to re-establish connections\n   * to those locations. If a connection is successfully re-established, it initiates a failback to the original\n   * location for the partition key range.\n   */\n  private async openConnectionToUnhealthyEndpointsWithFailback(): Promise<void> {\n    for (const pkRange of this.partitionKeyRangeToLocationForReadAndWrite.keys()) {\n      const partitionFailover = this.partitionKeyRangeToLocationForReadAndWrite.get(pkRange);\n      if (!partitionFailover) continue;\n\n      const { firstRequestFailureTime } =\n        await partitionFailover.snapshotPartitionFailoverTimestamps();\n      const now = new Date();\n\n      if (\n        now.getTime() - firstRequestFailureTime >\n        Constants.AllowedPartitionUnavailabilityDurationInMs\n      ) {\n        // Un-deterministically marking the original failed endpoint for the PkRange back to healthy.\n        // Initiate Failback to the original failed location.\n        this.partitionKeyRangeToLocationForReadAndWrite.delete(pkRange);\n      }\n    }\n  }\n}\n"]}