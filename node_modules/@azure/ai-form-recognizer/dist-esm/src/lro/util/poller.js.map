{"version":3,"file":"poller.js","sourceRoot":"","sources":["../../../../src/lro/util/poller.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport { delayMs } from \"./delayMs\";\n\nconst DEFAULT_POLLING_INTERVAL = 5000;\n\n/**\n * A specification for a long-running operation, which defines the poller flow.\n * @internal\n */\nexport interface OperationSpec<TState extends PollOperationState<unknown>> {\n  /**\n   * A function that produces the first operation state for this LRO.\n   */\n  init: () => Promise<TState>;\n  /**\n   * A function that consumes the existing state of the poller and produces the next state.\n   */\n  poll: (state: TState) => Promise<TState>;\n  /**\n   * A function that serializes the state into a string.\n   */\n  serialize: (state: TState) => string;\n}\n\n/**\n * Uniform poller implementation, creates a poller based on a PollerSpec.\n *\n * @internal\n */\nexport async function lro<TResult, TState extends PollOperationState<TResult>>(\n  spec: OperationSpec<TState>,\n  pollingInterval: number | undefined\n): Promise<PollerLike<TState, TResult>> {\n  let state = typeof spec.init === \"function\" ? await spec.init() : spec.init;\n\n  type ThisPoller = PollerLike<TState, TResult>;\n\n  // Job handling. If `job` is defined, then there is an active `pollUntilDone` call on this poller.\n  // Call `cancelJob` to interrupt the polling loop (awaiters will throw).\n  let job: Promise<TResult> | undefined;\n  let cancelJob: (() => void) | undefined;\n\n  // Progress handlers\n  type Handler = (state: TState) => void;\n  const handlers = new Map<symbol, Handler>();\n  const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n\n  const self: ThisPoller = {\n    onProgress: (callback: (state: TState) => void) => {\n      const s = Symbol();\n      handlers.set(s, callback);\n      return () => handlers.delete(s);\n    },\n    stopPolling: () => cancelJob?.(),\n    poll: async () => {\n      state = await spec.poll(state);\n      handleProgressEvents();\n    },\n    pollUntilDone: () =>\n      (job ??= (async () => {\n        // Technically, the poller could complete during initialization\n        if (!self.isDone()) {\n          // Poll once to get the ball rolling, this avoids a delay if the operation completes immediately\n          await self.poll();\n          while (!self.isDone()) {\n            const delay = delayMs(pollingInterval ?? DEFAULT_POLLING_INTERVAL);\n            cancelJob = delay.cancel;\n            await delay.then(() => self.poll());\n          }\n        }\n        const result = self.getResult();\n\n        // The state says it's done, so we know we are in either a success case, an error case, or an _internal_ error.\n        if (result !== undefined) return result;\n        else if (state.error !== undefined) throw state.error;\n        // Unreachable\n        else {\n          throw new Error(\n            `Internal Client Error: analysis poller completed without success or error: ${state}`\n          );\n        }\n      })().finally(() => {\n        job = undefined;\n      })),\n    // The poller is stopped if there is no job running\n    isStopped: () => !!job,\n    // The operation is complete if either a result or error is produced\n    isDone: () => !!state.result || !!state.error,\n    // In FR, all operations run to completion\n    cancelOperation() {\n      throw new Error(\"The Azure Form Recognizer service does not support operation cancellation.\");\n    },\n    getOperationState: () => state,\n    getResult: () => state.result,\n    toString: () => spec.serialize(state),\n  };\n\n  return self;\n}\n"]}