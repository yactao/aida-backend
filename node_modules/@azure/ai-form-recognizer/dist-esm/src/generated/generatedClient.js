/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
/// <reference lib="esnext.asynciterable" />
export class GeneratedClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for
     *                 example: https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-form-recognizer/4.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}/formrecognizer" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2022-08-31";
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.getOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getOperationsPagingPage(options);
            }
        };
    }
    getOperationsPagingPage(options) {
        return __asyncGenerator(this, arguments, function* getOperationsPagingPage_1() {
            let result = yield __await(this._getOperations(options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._getOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    getOperationsPagingAll(options) {
        return __asyncGenerator(this, arguments, function* getOperationsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.getOperationsPagingPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    listDocumentModels(options) {
        const iter = this.getDocumentModelsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getDocumentModelsPagingPage(options);
            }
        };
    }
    getDocumentModelsPagingPage(options) {
        return __asyncGenerator(this, arguments, function* getDocumentModelsPagingPage_1() {
            let result = yield __await(this._getDocumentModels(options));
            yield yield __await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield __await(this._getDocumentModelsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield __await(result.value || []);
            }
        });
    }
    getDocumentModelsPagingAll(options) {
        return __asyncGenerator(this, arguments, function* getDocumentModelsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.getDocumentModelsPagingPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Analyzes document with document model.
     * @param args Includes all the parameters for this operation.
     */
    analyzeDocument(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/octet-stream" ||
            args[1] === "application/pdf" ||
            args[1] === "image/bmp" ||
            args[1] === "image/heif" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeDocument$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeDocument$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Gets the result of document analysis.
     * @param modelId Unique document model name.
     * @param resultId Analyze operation result ID.
     * @param options The options parameters.
     */
    getAnalyzeDocumentResult(modelId, resultId, options) {
        return this.sendOperationRequest({ modelId, resultId, options }, getAnalyzeDocumentResultOperationSpec);
    }
    /**
     * Builds a custom document analysis model.
     * @param buildRequest Building request parameters.
     * @param options The options parameters.
     */
    buildDocumentModel(buildRequest, options) {
        return this.sendOperationRequest({ buildRequest, options }, buildDocumentModelOperationSpec);
    }
    /**
     * Creates a new document model from document types of existing document models.
     * @param composeRequest Compose request parameters.
     * @param options The options parameters.
     */
    composeDocumentModel(composeRequest, options) {
        return this.sendOperationRequest({ composeRequest, options }, composeDocumentModelOperationSpec);
    }
    /**
     * Generates authorization to copy a document model to this location with specified modelId and
     * optional description.
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param options The options parameters.
     */
    authorizeCopyDocumentModel(authorizeCopyRequest, options) {
        return this.sendOperationRequest({ authorizeCopyRequest, options }, authorizeCopyDocumentModelOperationSpec);
    }
    /**
     * Copies document model to the target resource, region, and modelId.
     * @param modelId Unique document model name.
     * @param copyToRequest Copy to request parameters.
     * @param options The options parameters.
     */
    copyDocumentModelTo(modelId, copyToRequest, options) {
        return this.sendOperationRequest({ modelId, copyToRequest, options }, copyDocumentModelToOperationSpec);
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    _getOperations(options) {
        return this.sendOperationRequest({ options }, getOperationsOperationSpec);
    }
    /**
     * Gets operation info.
     * @param operationId Unique operation ID.
     * @param options The options parameters.
     */
    getOperation(operationId, options) {
        return this.sendOperationRequest({ operationId, options }, getOperationOperationSpec);
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    _getDocumentModels(options) {
        return this.sendOperationRequest({ options }, getDocumentModelsOperationSpec);
    }
    /**
     * Gets detailed document model information.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    getDocumentModel(modelId, options) {
        return this.sendOperationRequest({ modelId, options }, getDocumentModelOperationSpec);
    }
    /**
     * Deletes document model.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    deleteDocumentModel(modelId, options) {
        return this.sendOperationRequest({ modelId, options }, deleteDocumentModelOperationSpec);
    }
    /**
     * Return information about the current resource.
     * @param options The options parameters.
     */
    getResourceDetails(options) {
        return this.sendOperationRequest({ options }, getResourceDetailsOperationSpec);
    }
    /**
     * GetOperationsNext
     * @param nextLink The nextLink from the previous successful call to the GetOperations method.
     * @param options The options parameters.
     */
    _getOperationsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, getOperationsNextOperationSpec);
    }
    /**
     * GetDocumentModelsNext
     * @param nextLink The nextLink from the previous successful call to the GetDocumentModels method.
     * @param options The options parameters.
     */
    _getDocumentModelsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, getDocumentModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const analyzeDocument$binaryOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.analyzeRequest,
    queryParameters: [
        Parameters.pages,
        Parameters.locale,
        Parameters.stringIndexType,
        Parameters.apiVersion
    ],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType, Parameters.accept],
    mediaType: "binary",
    serializer
};
const analyzeDocument$jsonOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.analyzeRequest1,
    queryParameters: [
        Parameters.pages,
        Parameters.locale,
        Parameters.stringIndexType,
        Parameters.apiVersion
    ],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType1, Parameters.accept1],
    mediaType: "json",
    serializer
};
const getAnalyzeDocumentResultOperationSpec = {
    path: "/documentModels/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeResultOperation
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],
    headerParameters: [Parameters.accept1],
    serializer
};
const buildDocumentModelOperationSpec = {
    path: "/documentModels:build",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientBuildDocumentModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.buildRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const composeDocumentModelOperationSpec = {
    path: "/documentModels:compose",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientComposeDocumentModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.composeRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const authorizeCopyDocumentModelOperationSpec = {
    path: "/documentModels:authorizeCopy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.CopyAuthorization
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.authorizeCopyRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const copyDocumentModelToOperationSpec = {
    path: "/documentModels/{modelId}:copyTo",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientCopyDocumentModelToHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.copyToRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept1, Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getOperationsOperationSpec = {
    path: "/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GetOperationsResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1],
    serializer
};
const getOperationOperationSpec = {
    path: "/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.OperationDetails
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.operationId],
    headerParameters: [Parameters.accept1],
    serializer
};
const getDocumentModelsOperationSpec = {
    path: "/documentModels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GetDocumentModelsResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1],
    serializer
};
const getDocumentModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DocumentModelDetails
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept1],
    serializer
};
const deleteDocumentModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.accept1],
    serializer
};
const getResourceDetailsOperationSpec = {
    path: "/info",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ResourceDetails
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.accept1],
    serializer
};
const getOperationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GetOperationsResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.nextLink],
    headerParameters: [Parameters.accept1],
    serializer
};
const getDocumentModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.GetDocumentModelsResponse
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [Parameters.endpoint, Parameters.nextLink],
    headerParameters: [Parameters.accept1],
    serializer
};
//# sourceMappingURL=generatedClient.js.map