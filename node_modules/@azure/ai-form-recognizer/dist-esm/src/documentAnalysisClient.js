// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { createTracingClient } from "@azure/core-tracing";
import { SDK_VERSION } from "./constants";
import { accept1 } from "./generated/models/parameters";
import { toAnalyzeResultFromGenerated, toDocumentAnalysisPollOperationState, } from "./lro/analysis";
import { lro } from "./lro/util/poller";
import { DEFAULT_GENERATED_CLIENT_OPTIONS, } from "./options/FormRecognizerClientOptions";
import { makeServiceClient, Mappers, SERIALIZER } from "./util";
/**
 * A client for interacting with the Form Recognizer service's analysis features.
 *
 * ### Examples:
 *
 * The Form Recognizer service and clients support two means of authentication:
 *
 * #### Azure Active Directory
 *
 * ```javascript
 * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```javascript
 * import { DocumentAnalysisClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 */
export class DocumentAnalysisClient {
    constructor(endpoint, credential, options = {}) {
        var _a;
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
        this._apiVersion = (_a = options.apiVersion) !== null && _a !== void 0 ? _a : DEFAULT_GENERATED_CLIENT_OPTIONS.apiVersion;
    }
    async beginAnalyzeDocument(model, document, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocument", options, this.analyze.bind(this, model, document));
    }
    async beginAnalyzeDocumentFromUrl(model, documentUrl, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocumentFromUrl", options, this.analyze.bind(this, model, documentUrl));
    }
    /**
     * A helper method for running analysis polymorphically.
     * @internal
     * @param model - the model ID or DocumentModel to use for analysis
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns - an analysis poller
     */
    analyze(model, input, options) {
        const { modelId: initialModelId, apiVersion: requestApiVersion, transformResult, } = typeof model === "string"
            ? { modelId: model, apiVersion: undefined, transformResult: (v) => v }
            : model;
        if (requestApiVersion && requestApiVersion !== this._apiVersion) {
            throw new Error([
                `API Version mismatch: the provided model wants version: ${requestApiVersion}, but the client is using ${this._apiVersion}.`,
                "The API version of the model must match the client's API version.",
            ].join("\n"));
        }
        return this.createAnalysisPoller(input, {
            initialModelId,
            options,
            transformResult: (result) => transformResult(toAnalyzeResultFromGenerated(result)),
        });
    }
    /**
     * Create an LRO poller that handles analysis operations.
     *
     * This is the meat of all analysis polling operations.
     *
     * @param input - either a string for URL inputs or a FormRecognizerRequestBody to upload a file directly to the Form
     *                Recognizer API
     * @param definition - operation definition (initial model ID, operation transforms, request options)
     * @returns - an analysis poller that produces the given return types according to the operation spec
     */
    async createAnalysisPoller(input, definition) {
        const { resumeFrom } = definition.options;
        // TODO: what should we do if resumeFrom.modelId is different from initialModelId?
        // And what do we do with the redundant input??
        const getAnalyzeResult = (operationLocation) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-getAnalyzeResult", definition.options, (finalOptions) => this._restClient.sendOperationRequest({
            options: finalOptions,
        }, {
            path: operationLocation,
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: Mappers.AnalyzeResultOperation,
                },
                default: {
                    bodyMapper: Mappers.ErrorResponse,
                },
            },
            // URL is fully-formed, so we don't need any query parameters
            headerParameters: [accept1],
            serializer: SERIALIZER,
        }));
        const toInit = 
        // If the user gave us a stored token, we'll poll it again
        resumeFrom !== undefined
            ? async () => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-resume", definition.options, async () => {
                const { operationLocation, modelId } = JSON.parse(resumeFrom);
                const result = await getAnalyzeResult(operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            })
            : // Otherwise, we'll start a new operation from the initialModelId
                async () => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-start", definition.options, async () => {
                    const [contentType, analyzeRequest] = toAnalyzeRequest(input);
                    const { operationLocation } = await this._restClient.analyzeDocument(definition.initialModelId, contentType, Object.assign(Object.assign({}, definition.options), { analyzeRequest }));
                    if (operationLocation === undefined) {
                        throw new Error("Unable to start analysis operation: no Operation-Location received.");
                    }
                    const result = await getAnalyzeResult(operationLocation);
                    return toDocumentAnalysisPollOperationState(definition, definition.initialModelId, operationLocation, result);
                });
        const poller = await lro({
            init: toInit,
            poll: async ({ operationLocation, modelId }) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-poll", {}, async () => {
                const result = await getAnalyzeResult(operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            }),
            serialize: ({ operationLocation, modelId }) => JSON.stringify({ modelId, operationLocation }),
        }, definition.options.updateIntervalInMs);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
}
/**
 * Produce an appropriate pair of content-type and analyzeRequest value for the analysis request.
 * @internal
 */
function toAnalyzeRequest(input) {
    if (typeof input === "string") {
        return [
            "application/json",
            {
                urlSource: input,
            },
        ];
    }
    else {
        return ["application/octet-stream", input];
    }
}
//# sourceMappingURL=documentAnalysisClient.js.map