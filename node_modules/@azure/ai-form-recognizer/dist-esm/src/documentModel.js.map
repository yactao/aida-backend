{"version":3,"file":"documentModel.js","sourceRoot":"","sources":["../../src/documentModel.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAMlC,OAAO,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAuBnD;;;;;;;GAOG;AACH,SAAS,YAAY,CACnB,SAAiB,EACjB,MAA2B,EAC3B,KAAoB;IAEpB,IAAI,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,EAAE;QAC9B,MAAM,IAAI,KAAK,CACb,qBAAqB,SAAS,cAAc,KAAK,CAAC,IAAI,oBAAoB,MAAM,CAAC,IAAI,GAAG,CACzF,CAAC;KACH;IAED,kFAAkF;IAClF,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;QAC3B,MAAM,MAAM,GAAQ,EAAE,CAAC;QAEvB,KAAK,MAAM,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,UAAW,CAAC,EAAE;YAC/E,IAAI,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,KAAK,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,KAAK,IAAI,EAAE;gBAC3F,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;oBAC3E,YAAY,CACV,SAAS,GAAG,GAAG,GAAG,YAAY,EAC9B,cAAc,EACd,KAAK,CAAC,UAAU,CAAC,YAAY,CAAE,CAChC,CAAC;aACL;SACF;QAED,uCACK,KAAK,KACR,UAAU,EAAE,MAAM,IAClB;KACH;SAAM,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE;QACjC,uCACK,KAAK,KACR,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CACpC,YAAY,CAAC,SAAS,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,MAAM,CAAC,KAAM,EAAE,GAAG,CAAC,CAC9D,IACD;KACH;;QAAM,OAAO,KAAK,CAAC;AACtB,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,qBAAqB,CACnC,MAA+C;IAE/C,OAAO;QACL,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,UAAU,EAAE,MAAM,CAAC,UAAsC;QACzD,eAAe,CAAC,UAAyB;;YACvC,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,MAAA,MAAM,CAAC,QAAQ,mCAAI,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;YAEtE,MAAM,gBAAgB,GAAG,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;YAEvD,uCACK,UAAU,KACb,SAAS,EAAE,MAAA,MAAA,UAAU,CAAC,SAAS,0CAAE,GAAG,CAAC,UAAU,CAAC,mCAAI,gBAAgB,IACpE;YAEF,SAAS,UAAU,CAAC,QAA0B;;gBAC5C,MAAM,MAAM,GAA4B,EAAE,CAAC;gBAC3C,MAAM,KAAK,GAAG,MAAA,MAAM,CAAC,QAAQ,0CAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;gBAElD,IAAI,KAAK,KAAK,SAAS,EAAE;oBACvB,MAAM,IAAI,KAAK,CACb,6BAA6B,QAAQ,CAAC,OAAO,4BAA4B,MAAM,CAAC,OAAO,GAAG,CAC3F,CAAC;iBACH;gBACD,KAAK,MAAM,CAAC,SAAS,EAAE,WAAW,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;oBACxE,IACE,QAAQ,CAAC,MAAM;wBACf,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,SAAS;wBACxC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,IAAI,EACnC;wBACA,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,GAAG,YAAY,CACjF,SAAS,EACT,WAAW,EACX,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAC3B,CAAC;qBACH;iBACF;gBAED,uCACK,QAAQ,KACX,MAAM,EAAE,MAAM,IACd;YACJ,CAAC;QACH,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DocumentFieldSchema, DocumentModelDetails } from \"./generated\";\nimport { AnalyzedDocument, AnalyzeResult } from \"./lro/analysis\";\nimport { DocumentField } from \"./models/fields\";\nimport { FormRecognizerApiVersion } from \"./options\";\nimport { isAcronymic, uncapitalize } from \"./util\";\n\n/**\n * A well-known model specification that supports extracting structured documents.\n *\n * See the `beginAnalyzeDocument` method of {@link DocumentAnalysisClient}, which supports consuming these\n * `DocumentModel` objects instead of model ID strings to provide stronger result types.\n */\nexport interface DocumentModel<Result> {\n  /**\n   * The unique ID of this model.\n   */\n  modelId: string;\n  /**\n   * The API version of the model.\n   */\n  apiVersion?: FormRecognizerApiVersion;\n  /**\n   * An associated transformation that is used to conver the base (weak) Result type to the strong version.\n   */\n  transformResult: (input: AnalyzeResult) => Result;\n}\n\n/**\n * Checks a field value against a schema and converts it into a strong idiomatic DocumentField,\n * @internal\n * @param fieldName - the name of the field (used in diagnostics)\n * @param schema - the field's schema\n * @param field - the raw DocumentField value\n * @returns\n */\nfunction extractField(\n  fieldName: string,\n  schema: DocumentFieldSchema,\n  field: DocumentField\n): DocumentField {\n  if (schema.type !== field.kind) {\n    throw new Error(\n      `Schema violation: ${fieldName} had type \"${field.kind}\", but expected \"${schema.type}\"`\n    );\n  }\n\n  // Objects need to be handled specially, so that we can camelCase the field names.\n  if (field.kind === \"object\") {\n    const result: any = {};\n\n    for (const [subFieldName, subFieldSchema] of Object.entries(schema.properties!)) {\n      if (field.properties[subFieldName] !== undefined && field.properties[subFieldName] !== null) {\n        result[isAcronymic(subFieldName) ? subFieldName : uncapitalize(subFieldName)] =\n          extractField(\n            fieldName + \".\" + subFieldName,\n            subFieldSchema,\n            field.properties[subFieldName]!\n          );\n      }\n    }\n\n    return {\n      ...field,\n      properties: result,\n    };\n  } else if (field.kind === \"array\") {\n    return {\n      ...field,\n      values: field.values.map((val, idx) =>\n        extractField(fieldName + \"[\" + idx + \"]\", schema.items!, val)\n      ),\n    };\n  } else return field;\n}\n\n/**\n * Create a DocumentModel that performs analysis using the given schema.\n *\n * The types of `documents` are created from the schema, so they are `unknown` unless they are asserted to be a\n * different type.\n *\n * @hidden\n * @param schema - model schema contents\n * @returns - a DocumentModel that encodes the schema\n */\nexport function createModelFromSchema(\n  schema: Omit<DocumentModelDetails, \"createdOn\">\n): DocumentModel<AnalyzeResult<unknown>> {\n  return {\n    modelId: schema.modelId,\n    apiVersion: schema.apiVersion as FormRecognizerApiVersion,\n    transformResult(baseResult: AnalyzeResult): AnalyzeResult<unknown> {\n      const hasDocuments = Object.entries(schema.docTypes ?? {}).length > 0;\n\n      const defaultDocuments = hasDocuments ? [] : undefined;\n\n      return {\n        ...baseResult,\n        documents: baseResult.documents?.map(toDocument) ?? defaultDocuments,\n      };\n\n      function toDocument(document: AnalyzedDocument): unknown {\n        const result: Record<string, unknown> = {};\n        const model = schema.docTypes?.[document.docType];\n\n        if (model === undefined) {\n          throw new Error(\n            `Unexpected document type \"${document.docType}\" in result using model \"${schema.modelId}\"`\n          );\n        }\n        for (const [fieldName, fieldSchema] of Object.entries(model.fieldSchema)) {\n          if (\n            document.fields &&\n            document.fields[fieldName] !== undefined &&\n            document.fields[fieldName] !== null\n          ) {\n            result[isAcronymic(fieldName) ? fieldName : uncapitalize(fieldName)] = extractField(\n              fieldName,\n              fieldSchema,\n              document.fields[fieldName]\n            );\n          }\n        }\n\n        return {\n          ...document,\n          fields: result,\n        };\n      }\n    },\n  };\n}\n"]}