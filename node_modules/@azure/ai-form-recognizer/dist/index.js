'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var coreTracing = require('@azure/core-tracing');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var tslib = require('tslib');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);
var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default AAD permissions scope for Cognitive Services.
 * @internal
 */
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * @internal
 */
const SDK_VERSION = "4.0.0";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AnalyzeDocumentRequest = {
    type: {
        name: "Composite",
        className: "AnalyzeDocumentRequest",
        modelProperties: {
            urlSource: {
                serializedName: "urlSource",
                type: {
                    name: "String"
                }
            },
            base64Source: {
                serializedName: "base64Source",
                type: {
                    name: "ByteArray"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const AnalyzeResultOperation = {
    type: {
        name: "Composite",
        className: "AnalyzeResultOperation",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["notStarted", "running", "failed", "succeeded"]
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            analyzeResult: {
                serializedName: "analyzeResult",
                type: {
                    name: "Composite",
                    className: "AnalyzeResult"
                }
            }
        }
    }
};
const AnalyzeResult = {
    type: {
        name: "Composite",
        className: "AnalyzeResult",
        modelProperties: {
            apiVersion: {
                serializedName: "apiVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                required: true,
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            pages: {
                serializedName: "pages",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentPage"
                        }
                    }
                }
            },
            paragraphs: {
                serializedName: "paragraphs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentParagraph"
                        }
                    }
                }
            },
            tables: {
                serializedName: "tables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentTable"
                        }
                    }
                }
            },
            keyValuePairs: {
                serializedName: "keyValuePairs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyValuePair"
                        }
                    }
                }
            },
            styles: {
                serializedName: "styles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentStyle"
                        }
                    }
                }
            },
            languages: {
                serializedName: "languages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            documents: {
                serializedName: "documents",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Document"
                        }
                    }
                }
            }
        }
    }
};
const DocumentPage = {
    type: {
        name: "Composite",
        className: "DocumentPage",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "pageNumber",
                required: true,
                type: {
                    name: "Number"
                }
            },
            angle: {
                constraints: {
                    InclusiveMaximum: 180,
                    ExclusiveMinimum: -180
                },
                serializedName: "angle",
                type: {
                    name: "Number"
                }
            },
            width: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "width",
                type: {
                    name: "Number"
                }
            },
            height: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "height",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            words: {
                serializedName: "words",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentWord"
                        }
                    }
                }
            },
            selectionMarks: {
                serializedName: "selectionMarks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSelectionMark"
                        }
                    }
                }
            },
            lines: {
                serializedName: "lines",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLine"
                        }
                    }
                }
            }
        }
    }
};
const DocumentSpan = {
    type: {
        name: "Composite",
        className: "DocumentSpan",
        modelProperties: {
            offset: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentWord = {
    type: {
        name: "Composite",
        className: "DocumentWord",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentSelectionMark = {
    type: {
        name: "Composite",
        className: "DocumentSelectionMark",
        modelProperties: {
            state: {
                serializedName: "state",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            span: {
                serializedName: "span",
                type: {
                    name: "Composite",
                    className: "DocumentSpan"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentLine = {
    type: {
        name: "Composite",
        className: "DocumentLine",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            polygon: {
                serializedName: "polygon",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentParagraph = {
    type: {
        name: "Composite",
        className: "DocumentParagraph",
        modelProperties: {
            role: {
                serializedName: "role",
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const BoundingRegion = {
    type: {
        name: "Composite",
        className: "BoundingRegion",
        modelProperties: {
            pageNumber: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "pageNumber",
                required: true,
                type: {
                    name: "Number"
                }
            },
            polygon: {
                serializedName: "polygon",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMinimum: 0
                        },
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const DocumentTable = {
    type: {
        name: "Composite",
        className: "DocumentTable",
        modelProperties: {
            rowCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rowCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columnCount: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columnCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            cells: {
                serializedName: "cells",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentTableCell"
                        }
                    }
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentTableCell = {
    type: {
        name: "Composite",
        className: "DocumentTableCell",
        modelProperties: {
            kind: {
                defaultValue: "content",
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            rowIndex: {
                serializedName: "rowIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            columnIndex: {
                serializedName: "columnIndex",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rowSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "rowSpan",
                type: {
                    name: "Number"
                }
            },
            columnSpan: {
                defaultValue: 1,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "columnSpan",
                type: {
                    name: "Number"
                }
            },
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentKeyValuePair = {
    type: {
        name: "Composite",
        className: "DocumentKeyValuePair",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "DocumentKeyValueElement"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DocumentKeyValueElement"
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentKeyValueElement = {
    type: {
        name: "Composite",
        className: "DocumentKeyValueElement",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            }
        }
    }
};
const DocumentStyle = {
    type: {
        name: "Composite",
        className: "DocumentStyle",
        modelProperties: {
            isHandwritten: {
                serializedName: "isHandwritten",
                type: {
                    name: "Boolean"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            locale: {
                serializedName: "locale",
                required: true,
                type: {
                    name: "String"
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Document = {
    type: {
        name: "Composite",
        className: "Document",
        modelProperties: {
            docType: {
                constraints: {
                    MaxLength: 64,
                    MinLength: 2
                },
                serializedName: "docType",
                required: true,
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            fields: {
                serializedName: "fields",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "DocumentField" } }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentField = {
    type: {
        name: "Composite",
        className: "DocumentField",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            valueString: {
                serializedName: "valueString",
                type: {
                    name: "String"
                }
            },
            valueDate: {
                serializedName: "valueDate",
                type: {
                    name: "Date"
                }
            },
            valueTime: {
                serializedName: "valueTime",
                type: {
                    name: "String"
                }
            },
            valuePhoneNumber: {
                serializedName: "valuePhoneNumber",
                type: {
                    name: "String"
                }
            },
            valueNumber: {
                serializedName: "valueNumber",
                type: {
                    name: "Number"
                }
            },
            valueInteger: {
                serializedName: "valueInteger",
                type: {
                    name: "Number"
                }
            },
            valueSelectionMark: {
                serializedName: "valueSelectionMark",
                type: {
                    name: "String"
                }
            },
            valueSignature: {
                serializedName: "valueSignature",
                type: {
                    name: "String"
                }
            },
            valueCountryRegion: {
                serializedName: "valueCountryRegion",
                type: {
                    name: "String"
                }
            },
            valueArray: {
                serializedName: "valueArray",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentField"
                        }
                    }
                }
            },
            valueObject: {
                serializedName: "valueObject",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "DocumentField" } }
                }
            },
            valueCurrency: {
                serializedName: "valueCurrency",
                type: {
                    name: "Composite",
                    className: "CurrencyValue"
                }
            },
            valueAddress: {
                serializedName: "valueAddress",
                type: {
                    name: "Composite",
                    className: "AddressValue"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            boundingRegions: {
                serializedName: "boundingRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BoundingRegion"
                        }
                    }
                }
            },
            spans: {
                serializedName: "spans",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSpan"
                        }
                    }
                }
            },
            confidence: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "confidence",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CurrencyValue = {
    type: {
        name: "Composite",
        className: "CurrencyValue",
        modelProperties: {
            amount: {
                serializedName: "amount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            currencySymbol: {
                serializedName: "currencySymbol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddressValue = {
    type: {
        name: "Composite",
        className: "AddressValue",
        modelProperties: {
            houseNumber: {
                serializedName: "houseNumber",
                type: {
                    name: "String"
                }
            },
            poBox: {
                serializedName: "poBox",
                type: {
                    name: "String"
                }
            },
            road: {
                serializedName: "road",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            postalCode: {
                serializedName: "postalCode",
                type: {
                    name: "String"
                }
            },
            countryRegion: {
                serializedName: "countryRegion",
                type: {
                    name: "String"
                }
            },
            streetAddress: {
                serializedName: "streetAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BuildDocumentModelRequest = {
    type: {
        name: "Composite",
        className: "BuildDocumentModelRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            buildMode: {
                serializedName: "buildMode",
                required: true,
                type: {
                    name: "String"
                }
            },
            azureBlobSource: {
                serializedName: "azureBlobSource",
                type: {
                    name: "Composite",
                    className: "AzureBlobContentSource"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AzureBlobContentSource = {
    type: {
        name: "Composite",
        className: "AzureBlobContentSource",
        modelProperties: {
            containerUrl: {
                serializedName: "containerUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "prefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComposeDocumentModelRequest = {
    type: {
        name: "Composite",
        className: "ComposeDocumentModelRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            componentModels: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "componentModels",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentDocumentModelDetails"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ComponentDocumentModelDetails = {
    type: {
        name: "Composite",
        className: "ComponentDocumentModelDetails",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizeCopyRequest = {
    type: {
        name: "Composite",
        className: "AuthorizeCopyRequest",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CopyAuthorization = {
    type: {
        name: "Composite",
        className: "CopyAuthorization",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetResourceRegion: {
                serializedName: "targetResourceRegion",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetModelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "targetModelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetModelLocation: {
                serializedName: "targetModelLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                required: true,
                type: {
                    name: "String"
                }
            },
            expirationDateTime: {
                serializedName: "expirationDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GetOperationsResponse = {
    type: {
        name: "Composite",
        className: "GetOperationsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationSummary = {
    type: {
        name: "Composite",
        className: "OperationSummary",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "failed",
                        "succeeded",
                        "canceled"
                    ]
                }
            },
            percentCompleted: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentCompleted",
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const OperationDetails = {
    type: {
        name: "Composite",
        className: "OperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "failed",
                        "succeeded",
                        "canceled"
                    ]
                }
            },
            percentCompleted: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentCompleted",
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdatedDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const GetDocumentModelsResponse = {
    type: {
        name: "Composite",
        className: "GetDocumentModelsResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentModelSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentModelSummary = {
    type: {
        name: "Composite",
        className: "DocumentModelSummary",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DocumentModelDetails = {
    type: {
        name: "Composite",
        className: "DocumentModelDetails",
        modelProperties: {
            modelId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
                },
                serializedName: "modelId",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            apiVersion: {
                serializedName: "apiVersion",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            docTypes: {
                serializedName: "docTypes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentTypeDetails" }
                    }
                }
            }
        }
    }
};
const DocumentTypeDetails = {
    type: {
        name: "Composite",
        className: "DocumentTypeDetails",
        modelProperties: {
            description: {
                constraints: {
                    MaxLength: 4096
                },
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            buildMode: {
                serializedName: "buildMode",
                type: {
                    name: "String"
                }
            },
            fieldSchema: {
                serializedName: "fieldSchema",
                required: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentFieldSchema" }
                    }
                }
            },
            fieldConfidence: {
                serializedName: "fieldConfidence",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Number" },
                        constraints: { InclusiveMaximum: 1, InclusiveMinimum: 0 }
                    }
                }
            }
        }
    }
};
const DocumentFieldSchema = {
    type: {
        name: "Composite",
        className: "DocumentFieldSchema",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            example: {
                serializedName: "example",
                type: {
                    name: "String"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Composite",
                    className: "DocumentFieldSchema"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DocumentFieldSchema" }
                    }
                }
            }
        }
    }
};
const ResourceDetails = {
    type: {
        name: "Composite",
        className: "ResourceDetails",
        modelProperties: {
            customDocumentModels: {
                serializedName: "customDocumentModels",
                type: {
                    name: "Composite",
                    className: "CustomDocumentModelsDetails"
                }
            }
        }
    }
};
const CustomDocumentModelsDetails = {
    type: {
        name: "Composite",
        className: "CustomDocumentModelsDetails",
        modelProperties: {
            count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentModelBuildOperationDetails = {
    serializedName: "documentModelBuild",
    type: {
        name: "Composite",
        className: "DocumentModelBuildOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const DocumentModelComposeOperationDetails = {
    serializedName: "documentModelCompose",
    type: {
        name: "Composite",
        className: "DocumentModelComposeOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const DocumentModelCopyToOperationDetails = {
    serializedName: "documentModelCopyTo",
    type: {
        name: "Composite",
        className: "DocumentModelCopyToOperationDetails",
        uberParent: "OperationDetails",
        polymorphicDiscriminator: OperationDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationDetails.type.modelProperties), { result: {
                serializedName: "result",
                type: {
                    name: "Composite",
                    className: "DocumentModelDetails"
                }
            } })
    }
};
const GeneratedClientAnalyzeDocumentHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeDocumentHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientBuildDocumentModelHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientBuildDocumentModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientComposeDocumentModelHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientComposeDocumentModelHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientCopyDocumentModelToHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientCopyDocumentModelToHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    OperationDetails: OperationDetails,
    "OperationDetails.documentModelBuild": DocumentModelBuildOperationDetails,
    "OperationDetails.documentModelCompose": DocumentModelComposeOperationDetails,
    "OperationDetails.documentModelCopyTo": DocumentModelCopyToOperationDetails
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnalyzeDocumentRequest: AnalyzeDocumentRequest,
    ErrorResponse: ErrorResponse,
    ErrorModel: ErrorModel,
    InnerError: InnerError,
    AnalyzeResultOperation: AnalyzeResultOperation,
    AnalyzeResult: AnalyzeResult,
    DocumentPage: DocumentPage,
    DocumentSpan: DocumentSpan,
    DocumentWord: DocumentWord,
    DocumentSelectionMark: DocumentSelectionMark,
    DocumentLine: DocumentLine,
    DocumentParagraph: DocumentParagraph,
    BoundingRegion: BoundingRegion,
    DocumentTable: DocumentTable,
    DocumentTableCell: DocumentTableCell,
    DocumentKeyValuePair: DocumentKeyValuePair,
    DocumentKeyValueElement: DocumentKeyValueElement,
    DocumentStyle: DocumentStyle,
    DocumentLanguage: DocumentLanguage,
    Document: Document,
    DocumentField: DocumentField,
    CurrencyValue: CurrencyValue,
    AddressValue: AddressValue,
    BuildDocumentModelRequest: BuildDocumentModelRequest,
    AzureBlobContentSource: AzureBlobContentSource,
    ComposeDocumentModelRequest: ComposeDocumentModelRequest,
    ComponentDocumentModelDetails: ComponentDocumentModelDetails,
    AuthorizeCopyRequest: AuthorizeCopyRequest,
    CopyAuthorization: CopyAuthorization,
    GetOperationsResponse: GetOperationsResponse,
    OperationSummary: OperationSummary,
    OperationDetails: OperationDetails,
    GetDocumentModelsResponse: GetDocumentModelsResponse,
    DocumentModelSummary: DocumentModelSummary,
    DocumentModelDetails: DocumentModelDetails,
    DocumentTypeDetails: DocumentTypeDetails,
    DocumentFieldSchema: DocumentFieldSchema,
    ResourceDetails: ResourceDetails,
    CustomDocumentModelsDetails: CustomDocumentModelsDetails,
    DocumentModelBuildOperationDetails: DocumentModelBuildOperationDetails,
    DocumentModelComposeOperationDetails: DocumentModelComposeOperationDetails,
    DocumentModelCopyToOperationDetails: DocumentModelCopyToOperationDetails,
    GeneratedClientAnalyzeDocumentHeaders: GeneratedClientAnalyzeDocumentHeaders,
    GeneratedClientBuildDocumentModelHeaders: GeneratedClientBuildDocumentModelHeaders,
    GeneratedClientComposeDocumentModelHeaders: GeneratedClientComposeDocumentModelHeaders,
    GeneratedClientCopyDocumentModelToHeaders: GeneratedClientCopyDocumentModelToHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: "contentType",
    mapper: {
        serializedName: "Content-Type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: [
                "application/octet-stream",
                "application/pdf",
                "image/bmp",
                "image/heif",
                "image/jpeg",
                "image/png",
                "image/tiff"
            ]
        }
    }
};
const analyzeRequest = {
    parameterPath: ["options", "analyzeRequest"],
    mapper: {
        serializedName: "analyzeRequest",
        type: {
            name: "Stream"
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: "contentType",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const analyzeRequest1 = {
    parameterPath: ["options", "analyzeRequest"],
    mapper: AnalyzeDocumentRequest
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const modelId = {
    parameterPath: "modelId",
    mapper: {
        constraints: {
            Pattern: new RegExp("[a-zA-Z0-9][a-zA-Z0-9._~-]{1,63}")
        },
        serializedName: "modelId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const pages = {
    parameterPath: ["options", "pages"],
    mapper: {
        constraints: {
            Pattern: new RegExp("^(\\d+(-\\d+)?)(,\\s*(\\d+(-\\d+)?))*$")
        },
        serializedName: "pages",
        type: {
            name: "String"
        }
    }
};
const locale = {
    parameterPath: ["options", "locale"],
    mapper: {
        serializedName: "locale",
        type: {
            name: "String"
        }
    }
};
const stringIndexType = {
    parameterPath: "stringIndexType",
    mapper: {
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-08-31",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const resultId = {
    parameterPath: "resultId",
    mapper: {
        serializedName: "resultId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType2 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const buildRequest = {
    parameterPath: "buildRequest",
    mapper: BuildDocumentModelRequest
};
const composeRequest = {
    parameterPath: "composeRequest",
    mapper: ComposeDocumentModelRequest
};
const authorizeCopyRequest = {
    parameterPath: "authorizeCopyRequest",
    mapper: AuthorizeCopyRequest
};
const copyToRequest = {
    parameterPath: "copyToRequest",
    mapper: CopyAuthorization
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns the innermost error that has a message field.
 *
 * @internal
 * @param error - the error to unwrap
 * @returns - the innermost populated error
 */
function unwrap(error) {
    if (error.innererror !== undefined && error.innererror.message !== undefined) {
        return unwrap(error.innererror);
    }
    return error;
}
/**
 * A class representing an Error from the Form Recognizer Service.
 *
 * For information about the error codes the service produces, refer to the service's error documentation:
 *
 * https://aka.ms/azsdk/formrecognizer/errors
 */
class FormRecognizerError extends Error {
    /**
     * Create a FormRecognizerError from a generated ErrorModel.
     * @internal
     * @hidden
     */
    constructor(formRecognizerError) {
        var _a;
        // TODO: We used to unwrap FR errors this way, but is it still necessary
        const e = unwrap(formRecognizerError);
        super(e.message);
        this.code = e.code;
        this.details = (_a = e.details) !== null && _a !== void 0 ? _a : [];
        this.target = e.target;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toBoundingPolygon(original) {
    const points = [];
    if (!original)
        return;
    if (original.length % 2 !== 0) {
        throw new Error("Unexpected number of points in the response, unable to translate as 2D points");
    }
    for (let i = 0; i < original.length; i += 2) {
        points.push({ x: original[i], y: original[i + 1] });
    }
    return points;
}
function toBoundingRegions(original) {
    return original === null || original === void 0 ? void 0 : original.map((region) => (Object.assign(Object.assign({}, region), { polygon: toBoundingPolygon(region.polygon) })));
}
function toDocumentTableFromGenerated(table) {
    return Object.assign(Object.assign({}, table), { boundingRegions: toBoundingRegions(table.boundingRegions), cells: table.cells.map((cell) => (Object.assign(Object.assign({}, cell), { boundingRegions: toBoundingRegions(cell.boundingRegions) }))) });
}
function toKeyValuePairFromGenerated(pair) {
    var _a;
    return Object.assign(Object.assign({}, pair), { key: Object.assign(Object.assign({}, pair.key), { boundingRegions: toBoundingRegions(pair.key.boundingRegions) }), value: pair.value
            ? Object.assign(Object.assign({}, pair.value), { boundingRegions: toBoundingRegions((_a = pair.value) === null || _a === void 0 ? void 0 : _a.boundingRegions) }) : undefined });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const APIM_SUBSCRIPTION_KEY_HEADER = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request using an `AzureKeyCredential` for Azure Form Recognizer
 * @internal
 */
function createFormRecognizerAzureKeyCredentialPolicy(credential) {
    return {
        name: "cognitiveServicesApimSubscriptionKeyCredentialPolicy",
        sendRequest(request, next) {
            request.headers.set(APIM_SUBSCRIPTION_KEY_HEADER, credential.key);
            return next(request);
        },
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class GeneratedClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for
     *                 example: https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        var _a, _b;
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-form-recognizer/4.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}/formrecognizer" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2022-08-31";
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    listOperations(options) {
        const iter = this.getOperationsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getOperationsPagingPage(options);
            }
        };
    }
    getOperationsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getOperationsPagingPage_1() {
            let result = yield tslib.__await(this._getOperations(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getOperationsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getOperationsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getOperationsPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getOperationsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    listDocumentModels(options) {
        const iter = this.getDocumentModelsPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.getDocumentModelsPagingPage(options);
            }
        };
    }
    getDocumentModelsPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* getDocumentModelsPagingPage_1() {
            let result = yield tslib.__await(this._getDocumentModels(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._getDocumentModelsNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    getDocumentModelsPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getDocumentModelsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getDocumentModelsPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Analyzes document with document model.
     * @param args Includes all the parameters for this operation.
     */
    analyzeDocument(...args) {
        let operationSpec;
        let operationArguments;
        let options;
        if (args[1] === "application/octet-stream" ||
            args[1] === "application/pdf" ||
            args[1] === "image/bmp" ||
            args[1] === "image/heif" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeDocument$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeDocument$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
            options = args[2];
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        operationArguments.options = options || {};
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Gets the result of document analysis.
     * @param modelId Unique document model name.
     * @param resultId Analyze operation result ID.
     * @param options The options parameters.
     */
    getAnalyzeDocumentResult(modelId, resultId, options) {
        return this.sendOperationRequest({ modelId, resultId, options }, getAnalyzeDocumentResultOperationSpec);
    }
    /**
     * Builds a custom document analysis model.
     * @param buildRequest Building request parameters.
     * @param options The options parameters.
     */
    buildDocumentModel(buildRequest, options) {
        return this.sendOperationRequest({ buildRequest, options }, buildDocumentModelOperationSpec);
    }
    /**
     * Creates a new document model from document types of existing document models.
     * @param composeRequest Compose request parameters.
     * @param options The options parameters.
     */
    composeDocumentModel(composeRequest, options) {
        return this.sendOperationRequest({ composeRequest, options }, composeDocumentModelOperationSpec);
    }
    /**
     * Generates authorization to copy a document model to this location with specified modelId and
     * optional description.
     * @param authorizeCopyRequest Authorize copy request parameters.
     * @param options The options parameters.
     */
    authorizeCopyDocumentModel(authorizeCopyRequest, options) {
        return this.sendOperationRequest({ authorizeCopyRequest, options }, authorizeCopyDocumentModelOperationSpec);
    }
    /**
     * Copies document model to the target resource, region, and modelId.
     * @param modelId Unique document model name.
     * @param copyToRequest Copy to request parameters.
     * @param options The options parameters.
     */
    copyDocumentModelTo(modelId, copyToRequest, options) {
        return this.sendOperationRequest({ modelId, copyToRequest, options }, copyDocumentModelToOperationSpec);
    }
    /**
     * Lists all operations.
     * @param options The options parameters.
     */
    _getOperations(options) {
        return this.sendOperationRequest({ options }, getOperationsOperationSpec);
    }
    /**
     * Gets operation info.
     * @param operationId Unique operation ID.
     * @param options The options parameters.
     */
    getOperation(operationId, options) {
        return this.sendOperationRequest({ operationId, options }, getOperationOperationSpec);
    }
    /**
     * List all document models
     * @param options The options parameters.
     */
    _getDocumentModels(options) {
        return this.sendOperationRequest({ options }, getDocumentModelsOperationSpec);
    }
    /**
     * Gets detailed document model information.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    getDocumentModel(modelId, options) {
        return this.sendOperationRequest({ modelId, options }, getDocumentModelOperationSpec);
    }
    /**
     * Deletes document model.
     * @param modelId Unique document model name.
     * @param options The options parameters.
     */
    deleteDocumentModel(modelId, options) {
        return this.sendOperationRequest({ modelId, options }, deleteDocumentModelOperationSpec);
    }
    /**
     * Return information about the current resource.
     * @param options The options parameters.
     */
    getResourceDetails(options) {
        return this.sendOperationRequest({ options }, getResourceDetailsOperationSpec);
    }
    /**
     * GetOperationsNext
     * @param nextLink The nextLink from the previous successful call to the GetOperations method.
     * @param options The options parameters.
     */
    _getOperationsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, getOperationsNextOperationSpec);
    }
    /**
     * GetDocumentModelsNext
     * @param nextLink The nextLink from the previous successful call to the GetDocumentModels method.
     * @param options The options parameters.
     */
    _getDocumentModelsNext(nextLink, options) {
        return this.sendOperationRequest({ nextLink, options }, getDocumentModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const analyzeDocument$binaryOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: analyzeRequest,
    queryParameters: [
        pages,
        locale,
        stringIndexType,
        apiVersion
    ],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType, accept],
    mediaType: "binary",
    serializer
};
const analyzeDocument$jsonOperationSpec = {
    path: "/documentModels/{modelId}:analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeDocumentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: analyzeRequest1,
    queryParameters: [
        pages,
        locale,
        stringIndexType,
        apiVersion
    ],
    urlParameters: [endpoint, modelId],
    headerParameters: [contentType1, accept1],
    mediaType: "json",
    serializer
};
const getAnalyzeDocumentResultOperationSpec = {
    path: "/documentModels/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeResultOperation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId, resultId],
    headerParameters: [accept1],
    serializer
};
const buildDocumentModelOperationSpec = {
    path: "/documentModels:build",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientBuildDocumentModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: buildRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1, contentType2],
    mediaType: "json",
    serializer
};
const composeDocumentModelOperationSpec = {
    path: "/documentModels:compose",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientComposeDocumentModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: composeRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1, contentType2],
    mediaType: "json",
    serializer
};
const authorizeCopyDocumentModelOperationSpec = {
    path: "/documentModels:authorizeCopy",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CopyAuthorization
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: authorizeCopyRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1, contentType2],
    mediaType: "json",
    serializer
};
const copyDocumentModelToOperationSpec = {
    path: "/documentModels/{modelId}:copyTo",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientCopyDocumentModelToHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: copyToRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept1, contentType2],
    mediaType: "json",
    serializer
};
const getOperationsOperationSpec = {
    path: "/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetOperationsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1],
    serializer
};
const getOperationOperationSpec = {
    path: "/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, operationId],
    headerParameters: [accept1],
    serializer
};
const getDocumentModelsOperationSpec = {
    path: "/documentModels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentModelsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1],
    serializer
};
const getDocumentModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DocumentModelDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept1],
    serializer
};
const deleteDocumentModelOperationSpec = {
    path: "/documentModels/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, modelId],
    headerParameters: [accept1],
    serializer
};
const getResourceDetailsOperationSpec = {
    path: "/info",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [accept1],
    serializer
};
const getOperationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetOperationsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept1],
    serializer
};
const getDocumentModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GetDocumentModelsResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept1],
    serializer
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Supported and common values of FormRecognizerApiVersion.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const FormRecognizerApiVersion = {
    /**
     * The newest version of the service known to be supported by the client (default).
     *
     * If using a beta package version, this will be identical to the latest preview version. Otherwise, it will be
     * identical to the latest stable version.
     */
    Latest: "2022-08-31",
    // TODO (GA): Add a `Stable` version selector that picks the latest GA version, even in beta packages, and an exact
    // version entry for the GA version.
    Stable: "2022-08-31",
};
/**
 * Supported values of StringIndexType.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const StringIndexType = {
    /**
     * UTF-16 code units
     */
    Utf16CodeUnit: "utf16CodeUnit",
    /**
     * Unicode code points
     */
    UnicodeCodePoint: "unicodeCodePoint",
};
/**
 * Default settings for Form Recognizer clients.
 *
 * @internal
 */
const DEFAULT_GENERATED_CLIENT_OPTIONS = {
    stringIndexType: StringIndexType.Utf16CodeUnit,
    apiVersion: FormRecognizerApiVersion.Stable,
};

// Copyright (c) Microsoft Corporation.
// This is used for URL request processing.
const SERIALIZER = coreClient.createSerializer(Mappers, false);
/**
 * Type-strong uncapitalization.
 * @internal
 */
const uncapitalize = (s) => (s.substring(0, 1).toLowerCase() + s.substring(1));
/**
 * Type-strong capitalization
 * @internal
 */
const capitalize = (s) => (s.substring(0, 1).toUpperCase() + s.substring(1));
/**
 * Tests if a string looks like it begins with an acronym, i.e. it starts with two capital letters.
 * @internal
 */
const isAcronymic = (s) => {
    return /^[A-Z][A-Z]/.test(s);
};
/**
 * Map an optional value through a function
 * @internal
 */
const maybemap = (value, f) => value === undefined ? undefined : f(value);
/**
 * Create a GeneratedClient.
 * @internal
 */
function makeServiceClient(endpoint, credential, options) {
    const client = new GeneratedClient(endpoint === null || endpoint === void 0 ? void 0 : endpoint.replace(/\/$/, ""), Object.assign(Object.assign({}, DEFAULT_GENERATED_CLIENT_OPTIONS), options));
    const authPolicy = coreAuth.isTokenCredential(credential)
        ? coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: DEFAULT_COGNITIVE_SCOPE,
        })
        : createFormRecognizerAzureKeyCredentialPolicy(credential);
    client.pipeline.addPolicy(authPolicy);
    return client;
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert a record of generated fields to a record of strongly-typed fields.
 * @internal
 * @param fields - a map of field names to generated field values
 * @returns - an object with the same keys, where all values have been mapped to DocumentFields
 */
function toAnalyzedDocumentFieldsFromGenerated(fields) {
    return Object.entries(fields !== null && fields !== void 0 ? fields : {}).reduce((transformedFields, [name, value]) => {
        transformedFields[name] = toDocumentField(value);
        return transformedFields;
    }, {});
}
/**
 * Convert a generated document field into a strong TypeScriptified document field.
 * @internal
 */
function toDocumentField(field) {
    const kind = field.type;
    const value = (() => {
        var _a, _b;
        switch (kind) {
            // Almost all value kinds are represented as simple elemental values
            case "string":
            case "date":
            case "time":
            case "phoneNumber":
            case "number":
            case "integer":
            case "selectionMark":
            case "countryRegion":
            case "signature":
            case "currency":
            case "address":
                return {
                    value: field[("value" + capitalize(kind))],
                };
            case "array":
                return { values: (_a = field.valueArray) === null || _a === void 0 ? void 0 : _a.map((v) => { var _a; return (_a = toDocumentField(v)) !== null && _a !== void 0 ? _a : []; }) };
            case "object":
                return { properties: toAnalyzedDocumentFieldsFromGenerated((_b = field.valueObject) !== null && _b !== void 0 ? _b : {}) };
            default:
                // Exhaustiveness check
                // eslint-disable-next-line no-case-declarations
                const __exhaust = kind;
                throw new Error(`Unrecognized DocumentField type: ${__exhaust}`);
        }
    })();
    return Object.assign(Object.assign({ kind }, value), { boundingRegions: toBoundingRegions(field.boundingRegions), content: field.content, spans: field.spans, confidence: field.confidence });
}

// Copyright (c) Microsoft Corporation.
/**
 * Transform a REST-level Document response object into the more strongly-typed AnalyzedDocument.
 *
 * @internal
 * @param document - a REST-level document response object
 * @returns an AnalyzedDocument (which has had its fields mapped to stronger DocumentField types)
 */
function toAnalyzedDocumentFromGenerated(document) {
    var _a;
    return Object.assign(Object.assign({}, document), { boundingRegions: toBoundingRegions(document.boundingRegions), fields: toAnalyzedDocumentFieldsFromGenerated((_a = document.fields) !== null && _a !== void 0 ? _a : {}) });
}
/**
 * Tests if one span contains another, by testing that the outer span starts before or at the same character as the
 * inner span, and that the end position of the outer span is greater than or equal to the end position of the inner
 * span.
 *
 * @internal
 * @param outer - the outer (potentially containing) span
 * @param inner - the span to test if `outer` contains
 * @returns true if `inner` is contained inside of `outer`.
 */
function contains(outer, inner) {
    return outer.offset <= inner.offset && outer.offset + outer.length >= inner.offset + inner.length;
}
/**
 * Make an empty generator. This might seem silly, but it's useful for satisfying invariants.
 */
function* empty() {
    /* intentionally empty */
}
/**
 * Produces an iterator of the given items starting from the given index.
 *
 * @param items - the items to iterate over
 * @param idx - the index of the first item to begin iterating from
 */
function* iterFrom(items, idx) {
    let i = idx;
    while (i < items.length) {
        yield items[i++];
    }
}
function toDocumentLineFromGenerated(generated, page) {
    generated.words = () => {
        var _a, _b;
        return fastGetChildren(iterFrom(generated.spans, 0), (_b = (_a = page.words) === null || _a === void 0 ? void 0 : _a.map((word) => {
            return Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) });
        })) !== null && _b !== void 0 ? _b : []);
    };
    generated.polygon = toBoundingPolygon(generated.polygon);
    Object.defineProperty(generated, "words", {
        enumerable: false,
    });
    return generated;
}
function toDocumentPageFromGenerated(generated) {
    var _a, _b, _c;
    return Object.assign(Object.assign({}, generated), { lines: (_a = generated.lines) === null || _a === void 0 ? void 0 : _a.map((line) => toDocumentLineFromGenerated(line, generated)), selectionMarks: (_b = generated.selectionMarks) === null || _b === void 0 ? void 0 : _b.map((mark) => (Object.assign(Object.assign({}, mark), { polygon: toBoundingPolygon(mark.polygon) }))), words: (_c = generated.words) === null || _c === void 0 ? void 0 : _c.map((word) => (Object.assign(Object.assign({}, word), { polygon: toBoundingPolygon(word.polygon) }))) });
}
/**
 * Binary search through an array of items to find the first item that could possibly be contained by the given span,
 * then return an iterator beginning from that item.
 *
 * This allows a program to quickly find the first relevant item in the array for consideration when testing for span
 * inclusion.
 *
 * @internal
 * @param span - the span to use when testing each individual item
 * @param items - an array of items to binary search through
 * @returns an iterator beginning from the item identified by the search
 */
function iteratorFromFirstMatchBinarySearch(span, items) {
    let idx = Math.floor(items.length / 2);
    let prevIdx = idx;
    let min = 0;
    let max = items.length;
    const found = () => { var _a, _b, _c; 
    // The item is found if it starts after the current span and the item before it does not. That means it is the first
    // item in the array that could be a child if the spans are sorted.
    return items[idx].span.offset >= span.offset && ((_c = (_b = (_a = items[idx - 1]) === null || _a === void 0 ? void 0 : _a.span) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : -1) < span.offset; };
    // Binary search to find the first element that could be a child
    do {
        if (found()) {
            return iterFrom(items, idx);
        }
        else if (span.offset > items[idx].span.offset) {
            min = prevIdx = idx;
            idx = Math.floor(idx + (max - idx) / 2);
        }
        else {
            max = prevIdx = idx;
            idx = Math.floor(idx - (idx - min) / 2);
        }
    } while (idx !== prevIdx);
    // This might seem weird, but it's a simple way to make the types a little more elegant.
    return empty();
}
/**
 * This fast algorithm tests the elements of `childArray` for inclusion in any of the given `spans`, assuming that both
 * the spans and child items are sorted.
 *
 * INVARIANT: the items in both the `spans` iterator and `childrenArray` MUST BE SORTED INCREASING by span _offset_.
 *
 * @internal
 * @param spans - the spans that contain the child elements
 * @param childrenArray - an array of child items (items that have spans) to test for inclusion in the spans
 * @returns - an IterableIterator of child items that are included in any span in the `spans` iterator
 */
function* fastGetChildren(spans, childrenArray) {
    let curSpan = spans.next();
    // Need to exit early if there are no spans.
    if (curSpan.done) {
        return;
    }
    const children = iteratorFromFirstMatchBinarySearch(curSpan.value, childrenArray);
    let curChild = children.next();
    while (!(curChild.done || curSpan.done)) {
        if (contains(curSpan.value, curChild.value.span)) {
            // The span is contained, so yield the current child and advance it.
            yield curChild.value;
            curChild = children.next();
        }
        else if (curSpan.value.offset + curSpan.value.length < curChild.value.span.offset) {
            // The current span ends before the next potential child starts, so advance the span
            curSpan = spans.next();
        }
        else {
            // The current child was not contained in the current span, so advance to the next child.
            curChild = children.next();
        }
    }
}
/**
 * Convert a generated AnalyzeResult into a convenience layer AnalyzeResult.
 * @internal
 */
function toAnalyzeResultFromGenerated(result) {
    var _a, _b, _c, _d;
    return {
        apiVersion: result.apiVersion,
        modelId: result.modelId,
        content: result.content,
        pages: result.pages.map((page) => toDocumentPageFromGenerated(page)),
        tables: (_a = result.tables) === null || _a === void 0 ? void 0 : _a.map((table) => toDocumentTableFromGenerated(table)),
        keyValuePairs: (_b = result.keyValuePairs) === null || _b === void 0 ? void 0 : _b.map((pair) => toKeyValuePairFromGenerated(pair)),
        languages: result.languages,
        styles: result.styles,
        paragraphs: (_c = result.paragraphs) === null || _c === void 0 ? void 0 : _c.map((para) => (Object.assign(Object.assign({}, para), { boundingRegions: toBoundingRegions(para.boundingRegions) }))),
        documents: (_d = result.documents) === null || _d === void 0 ? void 0 : _d.map(toAnalyzedDocumentFromGenerated),
    };
}
/**
 * Converts an AnalyzeResultOperation (LRO response) to a DocumentAnalysisPollOperationState
 * @internal
 */
function toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, response) {
    return {
        status: response.status,
        modelId: modelId,
        lastUpdatedOn: response.lastUpdatedOn,
        createdOn: response.createdOn,
        operationLocation,
        result: response.analyzeResult && definition.transformResult(response.analyzeResult),
        error: response.error && new FormRecognizerError(response.error),
        isCancelled: false,
        isStarted: response.status !== "notStarted",
        isCompleted: response.status === "succeeded",
    };
}

// Copyright (c) Microsoft Corporation.
const INTERRUPTED = "The local operation (timer) was interrupted or cancelled.";
/**
 * A promise that delays resolution until a certain amount of time (in milliseconds) has passed, with facilities for
 * robust cancellation.
 *
 * ### Example:
 *
 * ```javascript
 * let toCancel;
 *
 * // Wait 20 seconds, and optionally allow the function to be cancelled.
 * await delayMs(20000, (cancel) => { toCancel = cancel });
 *
 * // ... if `toCancel` is called before the 20 second timer expires, then the delayMs promise will reject.
 * ```
 *
 * @internal
 * @param ms - the number of milliseconds to wait before resolving
 * @param cb - a callback that can provide the caller with a cancellation function
 */
function delayMs(ms) {
    let aborted = false;
    let toReject;
    return Object.assign(new Promise((resolve, reject) => {
        let token;
        toReject = () => {
            maybemap(token, clearTimeout);
            reject(INTERRUPTED);
        };
        // In the rare case that the operation is _already_ aborted, we will reject instantly. This could happen, for
        // example, if the user calls the cancellation function immediately without yielding execution.
        if (aborted) {
            toReject();
        }
        else {
            token = setTimeout(resolve, ms);
        }
    }), {
        cancel: () => {
            aborted = true;
            toReject === null || toReject === void 0 ? void 0 : toReject();
        },
    });
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_POLLING_INTERVAL = 5000;
/**
 * Uniform poller implementation, creates a poller based on a PollerSpec.
 *
 * @internal
 */
async function lro(spec, pollingInterval) {
    let state = typeof spec.init === "function" ? await spec.init() : spec.init;
    // Job handling. If `job` is defined, then there is an active `pollUntilDone` call on this poller.
    // Call `cancelJob` to interrupt the polling loop (awaiters will throw).
    let job;
    let cancelJob;
    const handlers = new Map();
    const handleProgressEvents = async () => handlers.forEach((h) => h(state));
    const self = {
        onProgress: (callback) => {
            const s = Symbol();
            handlers.set(s, callback);
            return () => handlers.delete(s);
        },
        stopPolling: () => cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob(),
        poll: async () => {
            state = await spec.poll(state);
            handleProgressEvents();
        },
        pollUntilDone: () => (job !== null && job !== void 0 ? job : (job = (async () => {
            // Technically, the poller could complete during initialization
            if (!self.isDone()) {
                // Poll once to get the ball rolling, this avoids a delay if the operation completes immediately
                await self.poll();
                while (!self.isDone()) {
                    const delay = delayMs(pollingInterval !== null && pollingInterval !== void 0 ? pollingInterval : DEFAULT_POLLING_INTERVAL);
                    cancelJob = delay.cancel;
                    await delay.then(() => self.poll());
                }
            }
            const result = self.getResult();
            // The state says it's done, so we know we are in either a success case, an error case, or an _internal_ error.
            if (result !== undefined)
                return result;
            else if (state.error !== undefined)
                throw state.error;
            // Unreachable
            else {
                throw new Error(`Internal Client Error: analysis poller completed without success or error: ${state}`);
            }
        })().finally(() => {
            job = undefined;
        }))),
        // The poller is stopped if there is no job running
        isStopped: () => !!job,
        // The operation is complete if either a result or error is produced
        isDone: () => !!state.result || !!state.error,
        // In FR, all operations run to completion
        cancelOperation() {
            throw new Error("The Azure Form Recognizer service does not support operation cancellation.");
        },
        getOperationState: () => state,
        getResult: () => state.result,
        toString: () => spec.serialize(state),
    };
    return self;
}

// Copyright (c) Microsoft Corporation.
/**
 * A client for interacting with the Form Recognizer service's analysis features.
 *
 * ### Examples:
 *
 * The Form Recognizer service and clients support two means of authentication:
 *
 * #### Azure Active Directory
 *
 * ```javascript
 * import { DocumentAnalysisClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```javascript
 * import { DocumentAnalysisClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentAnalysisClient(endpoint, credential);
 * ```
 */
class DocumentAnalysisClient {
    constructor(endpoint, credential, options = {}) {
        var _a;
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = coreTracing.createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
        this._apiVersion = (_a = options.apiVersion) !== null && _a !== void 0 ? _a : DEFAULT_GENERATED_CLIENT_OPTIONS.apiVersion;
    }
    async beginAnalyzeDocument(model, document, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocument", options, this.analyze.bind(this, model, document));
    }
    async beginAnalyzeDocumentFromUrl(model, documentUrl, options = {}) {
        return this._tracing.withSpan("DocumentAnalysisClient.beginAnalyzeDocumentFromUrl", options, this.analyze.bind(this, model, documentUrl));
    }
    /**
     * A helper method for running analysis polymorphically.
     * @internal
     * @param model - the model ID or DocumentModel to use for analysis
     * @param input - the string URL or request body to use
     * @param options - analysis options
     * @returns - an analysis poller
     */
    analyze(model, input, options) {
        const { modelId: initialModelId, apiVersion: requestApiVersion, transformResult, } = typeof model === "string"
            ? { modelId: model, apiVersion: undefined, transformResult: (v) => v }
            : model;
        if (requestApiVersion && requestApiVersion !== this._apiVersion) {
            throw new Error([
                `API Version mismatch: the provided model wants version: ${requestApiVersion}, but the client is using ${this._apiVersion}.`,
                "The API version of the model must match the client's API version.",
            ].join("\n"));
        }
        return this.createAnalysisPoller(input, {
            initialModelId,
            options,
            transformResult: (result) => transformResult(toAnalyzeResultFromGenerated(result)),
        });
    }
    /**
     * Create an LRO poller that handles analysis operations.
     *
     * This is the meat of all analysis polling operations.
     *
     * @param input - either a string for URL inputs or a FormRecognizerRequestBody to upload a file directly to the Form
     *                Recognizer API
     * @param definition - operation definition (initial model ID, operation transforms, request options)
     * @returns - an analysis poller that produces the given return types according to the operation spec
     */
    async createAnalysisPoller(input, definition) {
        const { resumeFrom } = definition.options;
        // TODO: what should we do if resumeFrom.modelId is different from initialModelId?
        // And what do we do with the redundant input??
        const getAnalyzeResult = (operationLocation) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-getAnalyzeResult", definition.options, (finalOptions) => this._restClient.sendOperationRequest({
            options: finalOptions,
        }, {
            path: operationLocation,
            httpMethod: "GET",
            responses: {
                200: {
                    bodyMapper: AnalyzeResultOperation,
                },
                default: {
                    bodyMapper: ErrorResponse,
                },
            },
            // URL is fully-formed, so we don't need any query parameters
            headerParameters: [accept1],
            serializer: SERIALIZER,
        }));
        const toInit = 
        // If the user gave us a stored token, we'll poll it again
        resumeFrom !== undefined
            ? async () => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-resume", definition.options, async () => {
                const { operationLocation, modelId } = JSON.parse(resumeFrom);
                const result = await getAnalyzeResult(operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            })
            : // Otherwise, we'll start a new operation from the initialModelId
                async () => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-start", definition.options, async () => {
                    const [contentType, analyzeRequest] = toAnalyzeRequest(input);
                    const { operationLocation } = await this._restClient.analyzeDocument(definition.initialModelId, contentType, Object.assign(Object.assign({}, definition.options), { analyzeRequest }));
                    if (operationLocation === undefined) {
                        throw new Error("Unable to start analysis operation: no Operation-Location received.");
                    }
                    const result = await getAnalyzeResult(operationLocation);
                    return toDocumentAnalysisPollOperationState(definition, definition.initialModelId, operationLocation, result);
                });
        const poller = await lro({
            init: toInit,
            poll: async ({ operationLocation, modelId }) => this._tracing.withSpan("DocumentAnalysisClient.createAnalysisPoller-poll", {}, async () => {
                const result = await getAnalyzeResult(operationLocation);
                return toDocumentAnalysisPollOperationState(definition, modelId, operationLocation, result);
            }),
            serialize: ({ operationLocation, modelId }) => JSON.stringify({ modelId, operationLocation }),
        }, definition.options.updateIntervalInMs);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
}
/**
 * Produce an appropriate pair of content-type and analyzeRequest value for the analysis request.
 * @internal
 */
function toAnalyzeRequest(input) {
    if (typeof input === "string") {
        return [
            "application/json",
            {
                urlSource: input,
            },
        ];
    }
    else {
        return ["application/octet-stream", input];
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert an operation result into a training poller state.
 * @internal
 */
async function toTrainingPollOperationState(response) {
    var _a;
    return {
        operationId: response.operationId,
        status: response.status,
        apiVersion: response.apiVersion,
        percentCompleted: (_a = response.percentCompleted) !== null && _a !== void 0 ? _a : 0,
        lastUpdatedOn: response.lastUpdatedOn,
        createdOn: response.createdOn,
        error: response.error && new FormRecognizerError(response.error),
        isCancelled: response.status === "canceled",
        isCompleted: response.status === "succeeded",
        isStarted: response.status !== "notStarted",
        tags: response.tags,
        result: response.result,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * A client for interacting with the Form Recognizer service's model management features, such as creating, reading,
 * listing, deleting, and copying models.
 *
 * ### Examples:
 *
 * #### Azure Active Directory
 *
 * ```typescript
 * import { DocumentModelAdministrationClient } from "@azure/ai-form-recognizer";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new DefaultAzureCredential();
 *
 * const client = new DocumentModelAdministrationClient(endpoint, credential);
 * ```
 *
 * #### API Key (Subscription Key)
 *
 * ```typescript
 * import { DocumentModelAdministrationClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
 *
 * const endpoint = "https://<resource name>.cognitiveservices.azure.com";
 * const credential = new AzureKeyCredential("<api key>");
 *
 * const client = new DocumentModelAdministrationClient(endpoint, credential);
 * ```
 */
class DocumentModelAdministrationClient {
    constructor(endpoint, credential, options = {}) {
        this._restClient = makeServiceClient(endpoint, credential, options);
        this._tracing = coreTracing.createTracingClient({
            packageName: "@azure/ai-form-recognizer",
            packageVersion: SDK_VERSION,
            namespace: "Microsoft.CognitiveServices",
        });
    }
    // #region Model Creation
    /**
     * Build a new model with a given ID from a set of input documents and labeled fields.
     *
     * The Model ID can consist of any text, so long as it does not begin with "prebuilt-" (as these models refer to
     * prebuilt Form Recognizer models that are common to all resources), and so long as it does not already exist within
     * the resource.
     *
     * The Form Recognizer service reads the training data set from an Azure Storage container, given as a URL to the
     * container with a SAS token that allows the service backend to communicate with the container. At a minimum, the
     * "read" and "list" permissions are required. In addition, the data in the given container must be organized
     * according to a particular convention, which is documented in [the service's documentation for building custom
     * models](https://aka.ms/form-recognizer/custom).
     *
     * ### Example
     *
     * ```javascript
     * const modelId = "aNewModel";
     * const containerUrl = "<training data container SAS URL>";
     *
     * const poller = await client.beginBuildDocumentModel(modelId, containerUrl, {
     *   // Optionally, a text description may be attached to the model
     *   description: "This is an example model!"
     * });
     *
     * // Model building, like all other model creation operations, returns a poller that eventually produces a ModelDetails
     * // object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the model
     *   description, // identical to the description given when creating the model
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes // information about the document types in the model and their field schemas
     * } = modelDetails;
     * ```
     *
     * @param modelId - the unique ID of the model to create
     * @param containerUrl - SAS-encoded URL to an Azure Storage container holding the training data set
     * @param buildMode - the mode to use when building the model (see `DocumentModelBuildMode`)
     * @param options - optional settings for the model build operation
     * @returns a long-running operation (poller) that will eventually produce the created model information or an error
     */
    async beginBuildDocumentModel(modelId, containerUrl, buildMode, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginBuildDocumentModel", options, (finalOptions) => this.createDocumentModelPoller({
            options: finalOptions,
            start: () => this._restClient.buildDocumentModel({
                modelId,
                description: finalOptions.description,
                azureBlobSource: {
                    containerUrl,
                },
                buildMode,
            }, finalOptions),
        }));
    }
    /**
     * Creates a single composed model from several pre-existing submodels.
     *
     * The resulting composed model combines the document types of its component models, and inserts a classification step
     * into the extraction pipeline to determine which of its component submodels is most appropriate for the given input.
     *
     * ### Example
     *
     * ```javascript
     * const modelId = "aNewComposedModel";
     * const subModelIds = [
     *   "documentType1Model",
     *   "documentType2Model",
     *   "documentType3Model"
     * ];
     *
     * // The resulting composed model can classify and extract data from documents
     * // conforming to any of the above document types
     * const poller = await client.beginComposeDocumentModel(modelId, subModelIds, {
     *   description: "This is a composed model that can handle several document types."
     * });
     *
     * // Model composition, like all other model creation operations, returns a poller that eventually produces a
     * // ModelDetails object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the model
     *   description, // identical to the description given when creating the model
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes // information about the document types of the composed submodels
     * } = modelDetails;
     * ```
     *
     * @param modelId - the unique ID of the model to create
     * @param componentModelIds - an Iterable of strings representing the unique model IDs of the models to compose
     * @param options - optional settings for model creation
     * @returns a long-running operation (poller) that will eventually produce the created model information or an error
     */
    async beginComposeDocumentModel(modelId, componentModelIds, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginComposeDocumentModel", options, (finalOptions) => this.createDocumentModelPoller({
            options: finalOptions,
            start: () => this._restClient.composeDocumentModel({
                modelId,
                componentModels: [...componentModelIds].map((submodelId) => ({
                    modelId: submodelId,
                })),
                description: finalOptions.description,
                tags: finalOptions.tags,
            }, finalOptions),
        }));
    }
    /**
     * Creates an authorization to copy a model into the resource, used with the `beginCopyModelTo` method.
     *
     * The `CopyAuthorization` grants another cognitive service resource the right to create a model in this client's
     * resource with the model ID and optional description that are encoded into the authorization.
     *
     * ### Example
     *
     * ```javascript
     * // The copyAuthorization data structure stored below grants any cognitive services resource the right to copy a
     * // model into the client's resource with the given destination model ID.
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     * ```
     *
     * @param destinationModelId - the unique ID of the destination model (the ID to copy the model into)
     * @param options - optional settings for creating the copy authorization
     * @returns a copy authorization that encodes the given modelId and optional description
     */
    async getCopyAuthorization(destinationModelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getCopyAuthorization", options, (finalOptions) => this._restClient.authorizeCopyDocumentModel({
            modelId: destinationModelId,
            description: finalOptions.description,
            tags: finalOptions.tags,
        }, finalOptions));
    }
    /**
     * Copies a model with the given ID into the resource and model ID encoded by a given copy authorization.
     *
     * See {@link CopyAuthorization} and {@link getCopyAuthorization}.
     *
     * ### Example
     *
     * ```javascript
     * // We need a client for the source model's resource
     * const sourceEndpoint = "https://<source resource name>.cognitiveservices.azure.com";
     * const sourceCredential = new AzureKeyCredential("<source api key>");
     * const sourceClient = new DocumentModelAdministrationClient(sourceEndpoint, sourceCredential);
     *
     * // We create the copy authorization using a client authenticated with the destination resource. Note that these two
     * // resources can be the same (you can copy a model to a new ID in the same resource).
     * const copyAuthorization = await client.getCopyAuthorization("<destination model ID>");
     *
     * // Finally, use the _source_ client to copy the model and await the copy operation
     * const poller = await sourceClient.beginCopyModelTo("<source model ID>");
     *
     * // Model copying, like all other model creation operations, returns a poller that eventually produces a ModelDetails
     * // object
     * const modelDetails = await poller.pollUntilDone();
     *
     * const {
     *   modelId, // identical to the modelId given when creating the copy authorization
     *   description, // identical to the description given when creating the copy authorization
     *   createdOn, // the Date (timestamp) that the model was created
     *   docTypes // information about the document types of the model (identical to the original, source model)
     * } = modelDetails;
     * ```
     *
     * @param sourceModelId - the unique ID of the source model that will be copied
     * @param authorization - an authorization to copy the model, created using the {@link getCopyAuthorization}
     * @param options - optional settings for
     * @returns a long-running operation (poller) that will eventually produce the copied model information or an error
     */
    async beginCopyModelTo(sourceModelId, authorization, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.beginCopyModel", options, (finalOptions) => this.createDocumentModelPoller({
            options: finalOptions,
            start: () => this._restClient.copyDocumentModelTo(sourceModelId, authorization, finalOptions),
        }));
    }
    /**
     * Create an LRO poller that handles model creation operations.
     *
     * This is the meat of the above model creation operations.
     *
     * @param definition - operation definition (start operation method, request options)
     * @returns a model poller (produces a ModelDetails)
     */
    async createDocumentModelPoller(definition) {
        const { resumeFrom } = definition.options;
        const toInit = resumeFrom === undefined
            ? () => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-start", definition.options, async (options) => {
                const { operationLocation } = await definition.start();
                if (operationLocation === undefined) {
                    throw new Error("Unable to start model creation operation: no Operation-Location received.");
                }
                return this._restClient.sendOperationRequest({
                    options,
                }, {
                    path: operationLocation,
                    httpMethod: "GET",
                    responses: {
                        200: {
                            bodyMapper: OperationDetails,
                        },
                        default: {
                            bodyMapper: ErrorResponse,
                        },
                    },
                    headerParameters: [accept1],
                    serializer: SERIALIZER,
                });
            })
            : () => this._tracing.withSpan("DocumentModelAdministrationClient.createDocumentModelPoller-resume", definition.options, (options) => {
                const { operationId } = JSON.parse(resumeFrom);
                return this._restClient.getOperation(operationId, options);
            });
        const poller = await lro({
            init: async () => toTrainingPollOperationState(await toInit()),
            poll: async ({ operationId }) => this._tracing.withSpan("DocumentModelAdminstrationClient.createDocumentModelPoller-poll", definition.options, async (options) => {
                const res = await this._restClient.getOperation(operationId, options);
                return toTrainingPollOperationState(res);
            }),
            serialize: ({ operationId }) => JSON.stringify({ operationId }),
        }, definition.options.updateIntervalInMs);
        if (definition.options.onProgress !== undefined) {
            poller.onProgress(definition.options.onProgress);
            definition.options.onProgress(poller.getOperationState());
        }
        return poller;
    }
    // #endregion
    // #region Model Management
    /**
     * Retrieve basic information about this client's resource.
     *
     * ### Example
     *
     * ```javascript
     * const {
     *   // Information about the custom models in the current resource
     *   customDocumentModelDetails: {
     *     // The number of custom models in the current resource
     *     count,
     *     // The maximum number of models that the current resource can support
     *     limit
     *   }
     * } = await client.getResourceDetails();
     * ```
     *
     * @param options - optional settings for the request
     * @returns basic information about this client's resource
     */
    getResourceDetails(options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getResourceDetails", options, (finalOptions) => this._restClient.getResourceDetails(finalOptions));
    }
    /**
     * Retrieves information about a model ({@link ModelDetails}) by ID.
     *
     * This method can retrieve information about custom as well as prebuilt models.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `getModel` method could return any model, even
     * one that failed to create due to errors. In the new service versions, `getDocumentModel` and `listDocumentModels`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Example
     *
     * ```javascript
     * // The ID of the prebuilt business card model
     * const modelId = "prebuilt-businessCard";
     *
     * const {
     *   modelId, // identical to the modelId given when calling `getDocumentModel`
     *   description, // a textual description of the model, if provided during model creation
     *   createdOn, // the Date (timestamp) that the model was created
     *   // information about the document types in the model and their field schemas
     *   docTypes: {
     *     // the document type of the prebuilt business card model
     *     "prebuilt:businesscard": {
     *       // an optional, textual description of this document type
     *       description,
     *       // the schema of the fields in this document type, see the FieldSchema type
     *       fieldSchema,
     *       // the service's confidences in the fields (an object with field names as properties and numeric confidence
     *       // values)
     *       fieldConfidence
     *     }
     *   }
     * } = await client.getDocumentModel(modelId);
     * ```
     *
     * @param modelId - the unique ID of the model to query
     * @param options - optional settings for the request
     * @returns information about the model with the given ID
     */
    getDocumentModel(modelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getDocumentModel", options, (finalOptions) => this._restClient.getDocumentModel(modelId, finalOptions));
    }
    /**
     * List summaries of models in the resource. Custom as well as prebuilt models will be included. This operation
     * supports paging.
     *
     * The model summary ({@link ModelSummary}) includes only the basic information about the model, and does not include
     * information about the document types in the model (such as the field schemas and confidence values).
     *
     * To access the full information about the model, use {@link getDocumentModel}.
     *
     * ### **Breaking Change**
     *
     * In previous versions of the Form Recognizer REST API and SDK, the `listModels` method would return all models, even
     * those that failed to create due to errors. In the new service versions, `listDocumentModels` and `getDocumentModel`
     * _only produce successfully created models_ (i.e. models that are "ready" for use). Failed models are now retrieved
     * through the "operations" APIs, see {@link getOperation} and {@link listOperations}.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```javascript
     * for await (const summary of client.listDocumentModels()) {
     *   const {
     *     modelId, // The model's unique ID
     *     description, // a textual description of the model, if provided during model creation
     *   } = summary;
     *
     *   // You can get the full model info using `getDocumentModel`
     *   const model = await client.getDocumentModel(modelId);
     * }
     * ```
     *
     * #### By Page
     *
     * ```javascript
     * // The listDocumentModels method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listDocumentModels().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of models and can be iterated synchronously
     *   for (const model of page) {
     *     const {
     *       modelId, // The model's unique ID
     *       description, // a textual description of the model, if provided during model creation
     *     } = summary;
     *
     *     // You can get the full model info using `getDocumentModel`
     *     const model = await client.getDocumentModel(modelId);
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the model requests
     * @returns an async iterable of model summaries that supports paging
     */
    listDocumentModels(options = {}) {
        return this._restClient.listDocumentModels(options);
    }
    /**
     * Retrieves information about an operation (`OperationDetails`) by its ID.
     *
     * Operations represent non-analysis tasks, such as building, composing, or copying a model.
     *
     * @param operationId - the ID of the operation to query
     * @param options - optional settings for the request
     * @returns information about the operation with the given ID
     *
     * ### Example
     *
     * ```javascript
     * // The ID of the operation, which should be a GUID
     * const operationId = "<operation GUID>";
     *
     * const {
     *   operationId, // identical to the operationId given when calling `getOperation`
     *   kind, // the operation kind, one of "documentModelBuild", "documentModelCompose", or "documentModelCopyTo"
     *   status, // the status of the operation, one of "notStarted", "running", "failed", "succeeded", or "canceled"
     *   percentCompleted, // a number between 0 and 100 representing the progress of the operation
     *   createdOn, // a Date object that reflects the time when the operation was started
     *   lastUpdatedOn, // a Date object that reflects the time when the operation state was last modified
     * } = await client.getOperation(operationId);
     * ```
     */
    getOperation(operationId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.getOperation", options, (finalOptions) => this._restClient.getOperation(operationId, finalOptions));
    }
    /**
     * List model creation operations in the resource. This will produce all operations, including operations that failed
     * to create models successfully. This operation supports paging.
     *
     * ### Examples
     *
     * #### Async Iteration
     *
     * ```javascript
     * for await (const operation of client.listOperations()) {
     *   const {
     *     operationId, // the operation's GUID
     *     status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *     percentCompleted // the progress of the operation, from 0 to 100
     *   } = operation;
     * }
     * ```
     *
     * #### By Page
     *
     * ```javascript
     * // The listOperations method is paged, and you can iterate by page using the `byPage` method.
     * const pages = client.listOperations().byPage();
     *
     * for await (const page of pages) {
     *   // Each page is an array of operation info objects and can be iterated synchronously
     *   for (const operation of page) {
     *     const {
     *       operationId, // the operation's GUID
     *       status, // the operation status, one of "notStarted", "running", "succeeded", "failed", or "canceled"
     *       percentCompleted // the progress of the operation, from 0 to 100
     *     } = operation;
     *   }
     * }
     * ```
     *
     * @param options - optional settings for the operation requests
     * @returns an async iterable of operation information objects that supports paging
     */
    listOperations(options = {}) {
        return this._restClient.listOperations(options);
    }
    /**
     * Deletes a model with the given ID from the client's resource, if it exists. This operation CANNOT be reverted.
     *
     * ### Example
     *
     * ```javascript
     * await client.deleteModel("<model ID to delete>"));
     * ```
     *
     * @param modelId - the unique ID of the model to delete from the resource
     * @param options - optional settings for the request
     */
    deleteDocumentModel(modelId, options = {}) {
        return this._tracing.withSpan("DocumentModelAdministrationClient.deleteDocumentModel", options, (finalOptions) => this._restClient.deleteDocumentModel(modelId, finalOptions));
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Supported values of `DocumentModelBuildMode`.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const DocumentModelBuildMode = {
    /**
     * A mode that builds a model assuming that documents all follow the same, fixed template layout (the same relative
     * positioning of fields between documents).
     */
    Template: "template",
    /**
     * A mode that uses a neural engine to extract fields, allowing for documents that have different visual appearances,
     * but that contain the same information.
     */
    Neural: "neural",
};

// Copyright (c) Microsoft Corporation.
/**
 * Checks a field value against a schema and converts it into a strong idiomatic DocumentField,
 * @internal
 * @param fieldName - the name of the field (used in diagnostics)
 * @param schema - the field's schema
 * @param field - the raw DocumentField value
 * @returns
 */
function extractField(fieldName, schema, field) {
    if (schema.type !== field.kind) {
        throw new Error(`Schema violation: ${fieldName} had type "${field.kind}", but expected "${schema.type}"`);
    }
    // Objects need to be handled specially, so that we can camelCase the field names.
    if (field.kind === "object") {
        const result = {};
        for (const [subFieldName, subFieldSchema] of Object.entries(schema.properties)) {
            if (field.properties[subFieldName] !== undefined && field.properties[subFieldName] !== null) {
                result[isAcronymic(subFieldName) ? subFieldName : uncapitalize(subFieldName)] =
                    extractField(fieldName + "." + subFieldName, subFieldSchema, field.properties[subFieldName]);
            }
        }
        return Object.assign(Object.assign({}, field), { properties: result });
    }
    else if (field.kind === "array") {
        return Object.assign(Object.assign({}, field), { values: field.values.map((val, idx) => extractField(fieldName + "[" + idx + "]", schema.items, val)) });
    }
    else
        return field;
}
/**
 * Create a DocumentModel that performs analysis using the given schema.
 *
 * The types of `documents` are created from the schema, so they are `unknown` unless they are asserted to be a
 * different type.
 *
 * @hidden
 * @param schema - model schema contents
 * @returns - a DocumentModel that encodes the schema
 */
function createModelFromSchema(schema) {
    return {
        modelId: schema.modelId,
        apiVersion: schema.apiVersion,
        transformResult(baseResult) {
            var _a, _b, _c;
            const hasDocuments = Object.entries((_a = schema.docTypes) !== null && _a !== void 0 ? _a : {}).length > 0;
            const defaultDocuments = hasDocuments ? [] : undefined;
            return Object.assign(Object.assign({}, baseResult), { documents: (_c = (_b = baseResult.documents) === null || _b === void 0 ? void 0 : _b.map(toDocument)) !== null && _c !== void 0 ? _c : defaultDocuments });
            function toDocument(document) {
                var _a;
                const result = {};
                const model = (_a = schema.docTypes) === null || _a === void 0 ? void 0 : _a[document.docType];
                if (model === undefined) {
                    throw new Error(`Unexpected document type "${document.docType}" in result using model "${schema.modelId}"`);
                }
                for (const [fieldName, fieldSchema] of Object.entries(model.fieldSchema)) {
                    if (document.fields &&
                        document.fields[fieldName] !== undefined &&
                        document.fields[fieldName] !== null) {
                        result[isAcronymic(fieldName) ? fieldName : uncapitalize(fieldName)] = extractField(fieldName, fieldSchema, document.fields[fieldName]);
                    }
                }
                return Object.assign(Object.assign({}, document), { fields: result });
            }
        },
    };
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () { return coreAuth.AzureKeyCredential; }
});
exports.DocumentAnalysisClient = DocumentAnalysisClient;
exports.DocumentModelAdministrationClient = DocumentModelAdministrationClient;
exports.DocumentModelBuildMode = DocumentModelBuildMode;
exports.FormRecognizerApiVersion = FormRecognizerApiVersion;
exports.StringIndexType = StringIndexType;
exports.createModelFromSchema = createModelFromSchema;
//# sourceMappingURL=index.js.map
