"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPartitionKey = hashPartitionKey;
exports.binarySearchOnPartitionKeyRanges = binarySearchOnPartitionKeyRanges;
const index_js_1 = require("../../documents/index.js");
const batch_js_1 = require("../batch.js");
const multiHash_js_1 = require("./multiHash.js");
const v1_js_1 = require("./v1.js");
const v2_js_1 = require("./v2.js");
/**
 * Generate hash of a PartitonKey based on it PartitionKeyDefinition.
 * @param partitionKey - to be hashed.
 * @param partitionDefinition - container's partitionKey definition
 * @returns
 */
function hashPartitionKey(partitionKey, partitionDefinition) {
    const kind = partitionDefinition?.kind || index_js_1.PartitionKeyKind.Hash; // Default value.
    const isV2 = partitionDefinition &&
        partitionDefinition.version &&
        partitionDefinition.version === index_js_1.PartitionKeyDefinitionVersion.V2;
    switch (kind) {
        case index_js_1.PartitionKeyKind.Hash:
            return isV2 ? (0, v2_js_1.hashV2PartitionKey)(partitionKey) : (0, v1_js_1.hashV1PartitionKey)(partitionKey);
        case index_js_1.PartitionKeyKind.MultiHash:
            return (0, multiHash_js_1.hashMultiHashPartitionKey)(partitionKey);
    }
}
function binarySearchOnPartitionKeyRanges(partitionKeyRanges, hashedPartitionKey) {
    let low = 0;
    let high = partitionKeyRanges.length - 1;
    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const range = partitionKeyRanges[mid];
        if ((0, batch_js_1.isKeyInRange)(range.minInclusive, range.maxExclusive, hashedPartitionKey)) {
            return range.id;
        }
        else if (hashedPartitionKey.localeCompare(range.minInclusive) < 0) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return undefined;
}
//# sourceMappingURL=hash.js.map